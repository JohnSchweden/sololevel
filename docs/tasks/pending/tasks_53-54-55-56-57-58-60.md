# Tasks


---

## Task 53: Simplify VideoAnalysisScreen Architecture (Parent Tracker)
**Effort:** 3-5 days total | **Priority:** P1 (Technical Debt) | **Depends on:** None
**User Story:** N/A (Technical debt reduction - architectural simplification)

**STATUS:** ðŸŸ¢ **READY TO START** (Track subtasks 54-58)

### Summary

Simplify VideoAnalysisScreen from 13 hooks + 2 stores + 612 lines to 3-4 hooks + 1 store + ~150 lines using battle-tested patterns (YouTube/Vimeo architecture). Consolidate related functionality while keeping social features as UI placeholders.

**Progress Tracker:**
```
Task 54 (useVideoPlayer)      â†’ âœ… COMPLETE (2025-11-07)
Task 55 (useFeedbackSystem)   â†’ ðŸŸ¢ READY (1-2 days, depends on 54)
Task 56 (useAnalysis)         â†’ â¸ï¸ WAITING (1 day, depends on 55)
Task 57 (useFeedbackStore)    â†’ â¸ï¸ WAITING (1 day, depends on 56)
Task 58 (useVideoLayout)      â†’ â¸ï¸ WAITING (1 day, depends on 57, optional)
```

**Architectural Targets:**
- Hooks: 13 â†’ 3-4 (75% reduction)
- Stores: 2 â†’ 1 (50% reduction)
- Component LOC: ~612 â†’ ~150 (75% reduction)
- Pattern: Imperative ref API (YouTube/Vimeo style)

### Current State

- âŒ **13 hooks:** useVideoPlayback, useVideoControls, useVideoAudioSync, useAudioController, useFeedbackAudioSource, useAnalysisState, useFeedbackPanel, useFeedbackCoordinator, useHistoricalAnalysis, useAutoPlayOnReady, useGestureController, useAnimationController, useStatusBar
- âŒ **2 Zustand stores:** useFeedbackCoordinatorStore, usePersistentProgressStore
- âŒ **7 useMemo compositions:** videoState, playback, audio, feedback, handlers, error, socialCounts
- âœ… **Active features:** Feedback system, video playback
- âœ… **Social features:** Kept as placeholders (socialCounts, social actions, mock comments) for UI completeness
- âœ… **Architecture diagram:** `docs/spec/video-analysis-screen-architecture.mermaid`
- âœ… **Simplification proposal:** `docs/spec/video-analysis-simplification-proposal.md`

### Problem

- **Hook explosion:** 13 hooks creates complex dependency graph
- **Dual state management:** Zustand + local hooks adds cognitive overhead
- **Prop composition layers:** hook â†’ useMemo â†’ Screen â†’ Layout causes re-render cascades
- **Testing complexity:** Requires mocking 13 hooks + 2 stores
- **Pattern violation:** YouTube/Vimeo use 3-4 hooks max with imperative APIs

### Impact

- **Maintainability:** Developers must understand 13 hooks + 2 stores + 7 compositions
- **Performance:** Prop drilling and memoization overhead
- **Testing:** Complex mock setup for 13 hooks + 2 stores
- **Debugging:** State scattered across multiple sources
- **Onboarding:** Complex architecture discourages new contributors

### Subtasks

**See detailed implementation plans:**
- [x] **Task 54:** Consolidate Video Hooks â†’ useVideoPlayer (details: `docs/tasks/task-54-useVideoPlayer.md`)
- [ ] **Task 55:** Consolidate Feedback Hooks â†’ useFeedbackSystem (details: `docs/tasks/task-55-useFeedbackSystem.md`)
- [ ] **Task 56:** Consolidate Analysis Hooks â†’ useAnalysis (details: `docs/tasks/task-56-useAnalysis.md`)
- [ ] **Task 57:** Merge Stores â†’ Single useFeedbackStore (details: `docs/tasks/task-57-useFeedbackStore.md`)
- [ ] **Task 58:** (Optional) Consolidate Native Hooks â†’ useVideoLayout (details: `docs/tasks/task-58-useVideoLayout.md`)

### Success Validation

- [ ] All subtasks complete (Tasks 54-58)
- [ ] Hook count reduced from 13 â†’ 3-4 hooks (75% reduction)
- [ ] Store count reduced from 2 â†’ 1 store (50% reduction)
- [ ] Component lines reduced from 612 â†’ ~150 lines (75% reduction)
- [ ] Social features kept as placeholders (intentional UI completeness)
- [ ] Imperative API pattern implemented (YouTube/Vimeo style)
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] `yarn workspace @my/app test` passes (all tests)
- [ ] React DevTools Profiler shows performance improvement
- [ ] Architecture diagram updated: `docs/spec/video-analysis-simplified-architecture.mermaid`

### References

- **Simplification proposal:** `docs/spec/video-analysis-simplification-proposal.md`
- **Simplified architecture diagram:** `docs/spec/video-analysis-simplified-architecture.mermaid`
- **Current architecture diagram:** `docs/spec/video-analysis-screen-architecture.mermaid`
- **Detailed task plans:** `docs/tasks/task-{54,55,56,57,58}-*.md`

---

## Task 54: Consolidate Video Hooks â†’ useVideoPlayer
**Effort:** 1 day | **Priority:** P1 (Technical Debt) | **Depends on:** None  
**User Story:** N/A (Architectural consolidation - video playback)  
**Parent Task:** Task 53

**STATUS:** âœ… **COMPLETE** (2025-11-07)

### Completion Summary

- Consolidated legacy hooks into `useVideoPlayer` (Modules 1-7 âœ…), added exhaustive docs on normalized `initialStatus`, and left Module 8 (hook removal) deferred per validation plan.
- Updated `VideoAnalysisScreen` wiring, documentation, and normalization reminders to keep history-mode auto-play intact.
- Expanded regression suite to 16 tests covering legacy behaviours; verified with `yarn workspace @my/app test useVideoPlayer.test.ts`, `yarn workspace @my/app test VideoAnalysisScreen.test.tsx`, and `yarn workspace @my/app type-check`.

### Objective

Consolidate 4 video-related hooks (useVideoPlayback, useVideoControls, useVideoAudioSync, useAutoPlayOnReady) into single `useVideoPlayer` hook with imperative ref API (YouTube/Vimeo pattern).

### Current State

- âŒ 4 hooks: useVideoPlayback, useVideoControls, useVideoAudioSync, useAutoPlayOnReady
- âŒ Props passed through multiple composition layers
- âŒ Tight coupling between video playback and controls visibility
- âœ… Existing test files for all 4 hooks
- âœ… Well-defined interfaces in each hook

### Problem

- Video-related logic scattered across 4 hooks
- Each hook tested separately but integration untested
- Controls visibility tied to video state creates coupling
- No imperative API - all control via props

### Implementation Strategy

**Full details:** See `docs/tasks/task-54-useVideoPlayer.md`

**Summary:** Consolidate useVideoPlayback + useVideoControls + useVideoAudioSync + useAutoPlayOnReady into single hook with imperative ref API.

**Key Modules (9 total):**
1. Create useVideoPlayer interface
2. Implement core playback state
3. Add controls visibility logic
4. Integrate video-audio sync
5. Add imperative ref API
6. Integrate auto-play on ready
7. Create comprehensive tests
8. Update VideoAnalysisScreen
9. Remove old hooks

**Reference Pattern:** YouTube/Vimeo imperative ref API

### Interface

```typescript
export interface VideoPlayerRef {
  play: () => void
  pause: () => void
  seek: (time: number) => void
  replay: () => void
  getCurrentTime: () => number
  getDuration: () => number
}

export interface UseVideoPlayerReturn {
  ref: React.RefObject<VideoPlayerRef>
  isPlaying: boolean
  currentTime: number
  duration: number
  videoEnded: boolean
  pendingSeek: number | null
  showControls: boolean
  shouldPlayVideo: boolean
  onLoad: (data: { duration: number }) => void
  onProgress: (time: number) => void
  onEnd: () => void
}
```

### Acceptance Criteria

- [ ] Single hook replaces 4 hooks (4 â†’ 1 = 75% reduction)
- [ ] Imperative API matches YouTube/Vimeo pattern
- [ ] Test coverage â‰¥ 1:2 ratio
- [ ] `yarn workspace @my/app test useVideoPlayer.test.ts` passes
- [ ] VideoAnalysisScreen updated to use new hook
- [ ] Old hooks removed from codebase
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)

## Task 55: Rationalize Feedback Hooks â†’ Cohesive Feedback System
**Effort:** 1-2 days | **Priority:** P1 (Technical Debt) | **Depends on:** Task 54  
**User Story:** N/A (Architectural refinement - feedback system)  
**Parent Task:** Task 53

**STATUS:** ðŸŸ¢ **READY TO START** (Task 54 complete)

### Objective

Reduce feedback hook sprawl by merging only tightly-coupled audio concerns, slimming the coordinator, and providing an optional facade without reintroducing a god-hook.

### Current State

- âŒ 4 hooks: `useFeedbackCoordinator`, `useFeedbackAudioSource`, `useAudioController`, `useFeedbackPanel`
- âŒ Audio source + playback split, resulting in duplicated lifecycle handling
- âŒ Panel mutates coordinator-owned state through imperative setters
- âš ï¸ Coordinator owns orchestration + persistence side-effects, with sub-hooks for selection + bubbles
- âœ… Tests exist for all four hooks

### Problem

- Concern leakage across hooks forces VideoAnalysisScreen to juggle four tightly coupled dependencies
- Audio transport and source fetching always change together but live in separate hooks
- Panel exposes low-level setters, creating redundant state writes and extra memo layers
- Lack of a facade keeps the screen wiring verbose while still coupling to the low-level hooks

### Implementation Strategy

**Full details:** See `docs/tasks/task-55-useFeedbackSystem.md`

**Summary:** Introduce a dedicated `useFeedbackAudio` hook, trim `useFeedbackPanel`, focus `useFeedbackCoordinator` on orchestration, and add a thin `useFeedbackSystem` facade for ergonomic wiring.

**Key Modules (8 total):**
1. Establish shared types for audio, panel, coordinator, and facade contracts
2. Create `useFeedbackAudio` (merging source + transport)
3. Refine `useFeedbackPanel` to UI-only responsibilities
4. Slim `useFeedbackCoordinator` to orchestration + persistence side-effects
5. Add optional `useFeedbackSystem` facade that simply composes the three hooks
6. Update and expand hook test suites (audio, panel, coordinator, facade)
7. Update `VideoAnalysisScreen` to consume the new contracts
8. Remove superseded hooks (`useFeedbackAudioSource`, `useAudioController`) and update exports

**Reference Pattern:** Cohesive hooks per concern + thin facade (no god-hook logic)

### Interface Snapshot

```
useFeedbackAudio      // NEW: cohesive audio lifecycle
useFeedbackPanel      // UI-only state + events
useFeedbackCoordinator// Orchestration + persistence side-effects
useFeedbackSystem     // OPTIONAL thin facade
```

### Acceptance Criteria

- [ ] Hook count reduced from 4 â†’ 3 (audio consolidated; panel + coordinator remain focused)
- [ ] Optional facade returns stable object for screen wiring without embedding extra logic
- [ ] Test coverage â‰¥ 1:2 ratio across updated hooks
- [ ] `VideoAnalysisScreen` updated to consume the new contracts (facade or explicit trio)
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] `yarn workspace @my/app test useFeedback*.test.ts` passes (all relevant tests)
- [ ] Manual QA confirms audio/feedback flows unchanged

## Task 56: Consolidate Analysis Hooks â†’ useAnalysis
**Effort:** 1 day | **Priority:** P1 (Technical Debt) | **Depends on:** Task 55  
**User Story:** N/A (Architectural consolidation - analysis state)  
**Parent Task:** Task 53

**STATUS:** â¸ï¸ **WAITING** (Depends on Task 55)

### Objective

Consolidate 2 analysis hooks (useAnalysisState, useHistoricalAnalysis) into single `useAnalysis` hook that handles both history mode and live analysis modes.

### Current State

- âŒ 2 hooks: useAnalysisState, useHistoricalAnalysis
- âŒ History mode and live analysis handled separately
- âŒ Duplicate subscription and data fetching patterns
- âœ… Existing test files for both hooks
- âœ… Well-defined interfaces and phase tracking

### Problem

- Analysis logic split between history and live modes
- Duplicate state management patterns
- Mode switching requires understanding both hooks
- Historical analysis data fetched separately from live analysis

### Implementation Strategy

**Full details:** See `docs/tasks/task-56-useAnalysis.md`

**Summary:** Merge useAnalysisState + useHistoricalAnalysis into single hook with unified mode handling.

**Key Modules (9 total):**
1. Create useAnalysis interface
2. Implement core analysis state (live mode)
3. Integrate historical analysis data (history mode)
4. Implement error handling and retry
5. Integrate feedback items
6. Optimize subscriptions and queries
7. Create comprehensive tests
8. Update VideoAnalysisScreen
9. Remove old hooks

### Interface

```typescript
export interface UseAnalysisReturn {
  // Phase and progress
  phase: AnalysisPhase
  progress: number
  isProcessing: boolean
  
  // Data
  feedbackItems: FeedbackPanelItem[]
  videoUri: string | null
  
  // Error state
  error: AnalysisError | null
  channelExhausted: boolean
  
  // Actions
  retry: () => void
}
```

### Acceptance Criteria

- [ ] Single hook replaces 2 hooks (2 â†’ 1 = 50% reduction)
- [ ] Test coverage â‰¥ 1:2 ratio
- [ ] `yarn workspace @my/app test useAnalysis.test.ts` passes
- [ ] VideoAnalysisScreen updated to use new hook
- [ ] Old hooks removed from codebase
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)

## Task 57: Merge Stores â†’ Single useFeedbackStore
**Effort:** 1 day | **Priority:** P1 (Technical Debt) | **Depends on:** Task 56  
**User Story:** N/A (Architectural consolidation - state management)  
**Parent Task:** Task 53

**STATUS:** â¸ï¸ **WAITING** (Depends on Task 56)

### Objective

Merge 2 Zustand stores (useFeedbackCoordinatorStore, usePersistentProgressStore) into single `useFeedbackStore` for unified state management.

### Current State

- âŒ 2 stores: useFeedbackCoordinatorStore, usePersistentProgressStore
- âŒ Feedback state split across multiple stores
- âŒ Granular subscriptions to prevent re-renders
- âœ… Existing test files for both stores
- âœ… Immer middleware for immutable updates

### Problem

- Dual store pattern adds complexity
- State synchronization between stores
- Inconsistent subscription patterns
- More boilerplate for store management

### Implementation Strategy

**Full details:** See `docs/tasks/task-57-useFeedbackStore.md`

**Summary:** Merge useFeedbackCoordinatorStore + usePersistentProgressStore into single unified Zustand store.

**Key Modules (8 total):**
1. Design unified store interface
2. Create unified store implementation
3. Migrate coordinator store subscriptions
4. Migrate persistent progress store subscriptions
5. Update hook integrations
6. Create comprehensive tests
7. Remove old stores
8. Performance validation

### Interface

```typescript
export interface FeedbackStore extends FeedbackStoreState, FeedbackStoreActions {
  // Coordinator state
  highlightedFeedbackId: string | null
  isCoachSpeaking: boolean
  bubbleState: { currentBubbleIndex: number | null; bubbleVisible: boolean }
  overlayVisible: boolean
  activeAudio: { id: string; url: string } | null
  
  // Persistent progress state
  persistentProgressProps: PersistentProgressBarProps | null
  
  // Actions
  setHighlightedFeedbackId: (id: string | null) => void
  setIsCoachSpeaking: (speaking: boolean) => void
  setBubbleState: (state: BubbleState) => void
  setOverlayVisible: (visible: boolean) => void
  setActiveAudio: (audio: { id: string; url: string } | null) => void
  setPersistentProgressProps: (props: PersistentProgressBarProps | null) => void
  batchUpdate: (updates: Partial<FeedbackStoreState>) => void
  reset: () => void
}
```

### Acceptance Criteria

- [ ] Single store replaces 2 stores (2 â†’ 1 = 50% reduction)
- [ ] All subscriptions updated across codebase
- [ ] Test coverage â‰¥ 1:2 ratio
- [ ] `yarn workspace @my/app test feedbackStore.test.ts` passes
- [ ] Old stores removed from codebase
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] React DevTools Profiler shows no performance regression

## Task 58: (Optional) Consolidate Native Hooks â†’ useVideoLayout
**Effort:** 1 day | **Priority:** P2 (Optional Enhancement) | **Depends on:** Task 57  
**User Story:** N/A (Architectural consolidation - native gestures/animations)  
**Parent Task:** Task 53

**STATUS:** â¸ï¸ **WAITING** (Depends on Task 57, Optional)

### Objective

Consolidate 2 native-only hooks (useGestureController, useAnimationController) into single `useVideoLayout` hook (native only) to simplify gesture and animation coordination.

### Current State

- âŒ 2 hooks: useGestureController (450 LOC), useAnimationController (150 LOC)
- âŒ Gesture and animation logic tightly coupled
- âŒ Circular dependency (gesture needs animation refs, animation depends on gesture events)
- âœ… Native-only (no web implementation needed)
- âœ… Reanimated worklets for smooth 60fps animations
- âœ… YouTube-style gesture patterns (pan to seek, swipe panels)

### Problem

- Gesture requires animation refs for smooth transitions
- Animation depends on gesture events for state updates
- Circular dependency between hooks makes testing complex
- Large hooks (450 + 150 = 600 LOC) could be split differently

### Implementation Strategy

**Full details:** See `docs/tasks/task-58-useVideoLayout.md`

**Summary:** Merge useGestureController + useAnimationController into single native-only hook with gesture-animation coordination.

**Key Modules (8 total):**
1. Create useVideoLayout interface (native only)
2. Consolidate animation controller
3. Integrate gesture controller
4. Implement gesture-animation coordination
5. Add video seek integration (optional)
6. Create comprehensive tests
7. Update VideoAnalysisScreen (native only)
8. Remove old hooks

### Interface

```typescript
export interface UseVideoLayoutReturn {
  // Gesture
  panGesture: PanGesture
  feedbackScrollEnabled: boolean
  blockFeedbackScrollCompletely: boolean
  isPullingToRevealJS: boolean
  onFeedbackScrollY: (scrollY: number) => void
  onFeedbackMomentumScrollEnd: () => void
  
  // Animation
  scrollY: SharedValue<number>
  feedbackContentOffsetY: SharedValue<number>
  scrollRef: React.RefObject<Animated.ScrollView>
  collapseProgress: SharedValue<number>
}
```

### Acceptance Criteria

- [ ] Single hook replaces 2 hooks (2 â†’ 1 = 50% reduction, native only)
- [ ] Test coverage â‰¥ 1:2 ratio
- [ ] `yarn workspace @my/app test useVideoLayout.test.ts` passes
- [ ] VideoAnalysisScreen updated to use new hook
- [ ] Old hooks removed from codebase
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] Web build unaffected

### Notes

**Optional Task:** This task is optional and can be skipped if:
- Gesture and animation hooks work well separately
- Time constraints don't allow for consolidation
- Risk of breaking gesture behavior is too high

The main benefit is reducing hook count and simplifying the circular dependency. If skipped, Task 53 still achieves 75% hook reduction (13 â†’ 4 hooks instead of 13 â†’ 3).

---

## Task 60: Navigation Performance - Eliminate 200-300ms Screen Mount Overhead
**Effort:** 2-3 days | **Priority:** P0 (Critical Performance) | **Depends on:** None
**User Story:** US-NAV-01 (Navigation - Instant tab switches and screen transitions)

**STATUS:** ðŸŸ¢ **READY TO START**

### Objective

Eliminate 200-300ms screen mount overhead during navigation by implementing lazy loading, module prefetching, stable navigation options, transitions, and screen instance reuse. Target: <50ms initial paint, <100ms full interactive.

### Current State

**Evidence from logs:**
```
NavigationAppHeader render: 99-377ms per screen mount
- Header itself: <1ms (propsExtract: 0.00ms, useMemo: 0.06ms)
- Missing time: 200-360ms = screen mounting overhead
- Pattern: 2 renders per navigation (tab shell + nested screen)
```

**Problems:**
- âŒ **Screen mount overhead:** 200-360ms per navigation
- âŒ **Synchronous heavy imports:** VisionCamera, MVPPoseDetection, Tamagui themes, SafeArea
- âŒ **Unstable navigation options:** New objects/lambdas every render
- âŒ **No transitions:** Route pushes block JS thread
- âŒ **Full remounts:** Every settings subsection nukes entire screen tree

**Impact:**
- Settings navigation: 147-377ms per screen (4 renders per route)
- Record screen: 303ms + 272ms = 2 renders on first mount
- Coach screen: 226ms + 244ms = 2 renders on first mount
- Tab switches: 99-161ms initial paint

### Root Cause Analysis

```
Navigation tap
     â†“
Stack unmounts current screen (expensive)
     â†“
Stack mounts new screen (expensive)
     â†“
Screen imports heavy modules synchronously:
  - VisionCamera (~50ms)
  - MVPPoseDetection (~30ms)
  - Tamagui theme resolution (~20ms)
  - SafeAreaView calculation (~20ms)
  - react-native-worklets-core (~30ms)
     â†“
Screen creates unstable options objects:
  - New lambdas for onMenuPress, onBackPress
  - New appHeaderProps object every render
     â†“
React Navigation re-renders header 2x:
  1. Tab shell render (100-150ms)
  2. Nested screen render (100-200ms)
     â†“
Total: 200-360ms blocked JS thread
```

### Implementation Strategy

#### Module 1: Lazy Screen Loading âš¡ HIGH IMPACT
**Effort:** 1 day | **Impact:** 60-100ms reduction

**Summary:** Split screens into lightweight shells + deferred content using Suspense or staged layouts.

**Files to modify:**
- `apps/expo/app/(tabs)/record.tsx` - Split camera screen into shell + deferred content
- `apps/expo/app/settings/*.tsx` - Lazy load settings content
- `apps/expo/app/(tabs)/coach.tsx` - Defer chat/mirror heavy components

**Pattern:**
```typescript
// Before: Synchronous heavy import
import { CameraScreen } from '@my/app/features/CameraRecording'

export default function RecordRoute() {
  return <CameraScreen onNavigate={...} />
}

// After: Lazy shell + deferred content
import { Suspense, lazy } from 'react'

const CameraContent = lazy(() => 
  import('@my/app/features/CameraRecording').then(m => ({ default: m.CameraScreen }))
)

export default function RecordRoute() {
  return (
    <Suspense fallback={<CameraShell />}>
      <CameraContent onNavigate={...} />
    </Suspense>
  )
}

const CameraShell = () => (
  <View style={styles.shell}>
    <Text>Loading camera...</Text>
  </View>
)
```

**Acceptance Criteria:**
- [ ] Record screen: Shell renders in <50ms, full content in <150ms
- [ ] Settings screens: Shell renders in <30ms, content loads async
- [ ] Coach screen: Shell renders in <50ms, chat loads async
- [ ] Suspense fallbacks shown during lazy load
- [ ] No visual flash or layout shift

#### Module 2: Stable Navigation Options âš¡ HIGH IMPACT
**Effort:** 1 day | **Impact:** 50-100ms reduction (prevents double renders)

**Summary:** Memoize navigation options objects and callbacks to prevent React Navigation thrashing.

**Files to modify:**
- `apps/expo/app/(tabs)/_layout.tsx` - Memoize appHeaderProps, tab options
- `apps/expo/app/settings/_layout.tsx` - Memoize settings stack options
- All route files with `navigation.setOptions()` calls

**Pattern:**
```typescript
// Before: New objects every render
navigation.setOptions({
  appHeaderProps: {
    onMenuPress: () => router.push('/menu'), // New lambda
    onBackPress: () => router.back(), // New lambda
  },
})

// After: Stable memoized objects
const onMenuPress = useCallback(() => router.push('/menu'), [router])
const onBackPress = useCallback(() => router.back(), [router])

const appHeaderProps = useMemo(() => ({
  onMenuPress,
  onBackPress,
}), [onMenuPress, onBackPress])

useLayoutEffect(() => {
  navigation.setOptions({ appHeaderProps })
}, [appHeaderProps])
```

**Acceptance Criteria:**
- [ ] All navigation options use `useMemo` or `useCallback`
- [ ] `appHeaderProps` objects stable across renders
- [ ] Route options use stable references
- [ ] React Navigation header re-renders reduced from 2 â†’ 1 per navigation

#### Module 3: Module Prefetching âš¡ MEDIUM IMPACT
**Effort:** 0.5 days | **Impact:** 30-50ms reduction

**Summary:** Preload heavy modules before user taps tabs using route-based prefetch or boot hook.

**Files to create:**
- `packages/app/utils/modulePrefetch.ts` - Centralized prefetch logic

**Files to modify:**
- `apps/expo/app/_layout.tsx` - Add prefetch boot hook
- `apps/expo/app/(tabs)/_layout.tsx` - Prefetch on tab focus

**Pattern:**
```typescript
// packages/app/utils/modulePrefetch.ts
export const prefetchModules = {
  camera: async () => {
    await Promise.all([
      import('react-native-vision-camera'),
      import('react-native-worklets-core'),
      import('@my/app/features/CameraRecording/hooks/useMVPPoseDetection'),
    ])
  },
  
  coach: async () => {
    await import('@my/app/features/Coach/CoachScreen')
  },
  
  settings: async () => {
    await import('@my/app/features/Settings/SettingsScreen')
  },
}

// apps/expo/app/(tabs)/_layout.tsx
const Tab = withLayoutContext(createBottomTabNavigator())

export default function TabsLayout() {
  const [activeTab, setActiveTab] = useState('coach')
  
  // Prefetch next likely tab on focus
  useEffect(() => {
    const prefetchNext = async () => {
      if (activeTab === 'coach') {
        await prefetchModules.camera() // User likely to record next
      } else if (activeTab === 'record') {
        await prefetchModules.coach() // User likely to review
      }
    }
    
    const timer = setTimeout(prefetchNext, 500) // Wait 500ms after tab switch
    return () => clearTimeout(timer)
  }, [activeTab])
  
  return <Tab.Navigator ... />
}
```

**Acceptance Criteria:**
- [ ] Heavy modules prefetched before first use
- [ ] Boot hook prefetches critical modules on app start
- [ ] Tab focus prefetches next likely screen
- [ ] First camera mount: <150ms (from 303ms)
- [ ] First coach mount: <100ms (from 226ms)

#### Module 4: Route Transitions with startTransition ðŸ”§ LOW IMPACT
**Effort:** 0.5 days | **Impact:** 10-20ms smoother UX (doesn't reduce total time)

**Summary:** Wrap route pushes and large state updates in `startTransition` so React yields without blocking.

**Files to modify:**
- `apps/expo/app/(tabs)/_layout.tsx` - Wrap navigation calls
- All route files with `router.push()` or `navigation.navigate()` calls

**Pattern:**
```typescript
import { startTransition } from 'react'

// Before: Blocks JS thread
const handleNavigate = () => {
  router.push('/settings/account')
}

// After: Yields to browser/native thread
const handleNavigate = () => {
  startTransition(() => {
    router.push('/settings/account')
  })
}

// For large state updates
const handleVideoLoad = (data) => {
  startTransition(() => {
    setDuration(data.duration)
    setVideoReady(true)
    // ... other state updates
  })
}
```

**Acceptance Criteria:**
- [ ] All `router.push()` wrapped in `startTransition`
- [ ] All `navigation.navigate()` wrapped in `startTransition`
- [ ] Large state updates wrapped in `startTransition`
- [ ] No visual regression or timing bugs
- [ ] User perceives smoother navigation (qualitative)

#### Module 5: Screen Instance Reuse ðŸ”§ MEDIUM IMPACT
**Effort:** 1 day | **Impact:** 50-100ms reduction for settings subsections

**Summary:** Prevent full screen remounts for settings subsections by nesting stacks or using stateful shells.

**Files to modify:**
- `apps/expo/app/settings/_layout.tsx` - Add nested stack or stateful shell
- `apps/expo/app/settings/*.tsx` - Convert to content components

**Current behavior:**
```
Settings â†’ Account (unmount Settings, mount Account)
Account â†’ Personalisation (unmount Account, mount Personalisation)
```

**Desired behavior (Option A - Nested Stack):**
```
Settings Shell (stays mounted)
  â†“
  Stack Navigator
    â”œâ”€â”€ Account (content only)
    â”œâ”€â”€ Personalisation (content only)
    â””â”€â”€ Security (content only)
```

**Desired behavior (Option B - Stateful Shell):**
```
Settings Shell (stays mounted, manages state)
  â†“
  Conditional render based on route
  â”œâ”€â”€ if route === 'account' â†’ <AccountContent />
  â”œâ”€â”€ if route === 'personalisation' â†’ <PersonalisationContent />
  â””â”€â”€ if route === 'security' â†’ <SecurityContent />
```

**Pattern (Option A - Recommended):**
```typescript
// apps/expo/app/settings/_layout.tsx
export default function SettingsLayout() {
  return (
    <SettingsShell>
      <Stack>
        <Stack.Screen name="account" component={AccountContent} />
        <Stack.Screen name="personalisation" component={PersonalisationContent} />
        <Stack.Screen name="security" component={SecurityContent} />
      </Stack>
    </SettingsShell>
  )
}

const SettingsShell = ({ children }) => (
  <View style={styles.shell}>
    {/* Common settings UI */}
    {children}
  </View>
)
```

**Acceptance Criteria:**
- [ ] Settings navigation: No full screen remounts
- [ ] Settings subsections: <50ms transitions (from 147-377ms)
- [ ] Settings shell: Stays mounted during navigation
- [ ] Settings content: Lightweight, quick to mount
- [ ] Back navigation: Works correctly
- [ ] No memory leaks from retained screens

### Success Metrics

**Before (current):**
- Settings navigation: 147-377ms per screen (4 renders per route)
- Record screen: 303ms initial mount
- Coach screen: 226ms initial mount
- Tab switches: 99-161ms initial paint
- Header renders: 2 per navigation

**After (target):**
- Settings navigation: <50ms per screen (1-2 renders)
- Record screen: <150ms initial mount (50% reduction)
- Coach screen: <100ms initial mount (55% reduction)
- Tab switches: <50ms initial paint (50% reduction)
- Header renders: 1 per navigation (50% reduction)

### Validation

**Manual QA:**
```bash
# Start app with profiling
yarn native

# Navigate through all tabs
# Record screen â†’ Coach screen â†’ Insights screen â†’ Settings

# Navigate through settings subsections
# Account â†’ Personalisation â†’ Security â†’ Data â†’ Feedback

# Expected:
# - Tab switches: <50ms first paint
# - Settings navigation: <50ms transitions
# - No visual flash or jank
# - Smooth animations
```

**Automated checks:**
```bash
yarn type-check
yarn lint
yarn workspace @my/app test
```

**Performance logs:**
```
âœ… NavigationAppHeader: <50ms (from 99-377ms)
âœ… Settings transitions: <50ms (from 147-377ms)
âœ… Tab switches: <50ms first paint (from 99-161ms)
âœ… Header renders: 1 per navigation (from 2)
```

### Completion Criteria

- [ ] Module 1: Lazy screen loading implemented (Suspense + shells)
- [ ] Module 2: Navigation options stabilized (useMemo + useCallback)
- [ ] Module 3: Heavy modules prefetched (boot hook + tab focus)
- [ ] Module 4: Route transitions use startTransition
- [ ] Module 5: Screen instance reuse for settings subsections
- [ ] Manual QA: All navigations feel instant (<50ms perceived)
- [ ] Performance logs: <50ms for all navigations
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] No memory leaks or visual regressions
- [ ] Documentation updated with performance patterns

### Technical Notes

**Battle-tested patterns:**
- **Lazy loading:** Next.js, React Router v6, Expo Router lazy imports
- **Stable options:** Expo Router examples, React Navigation docs
- **Prefetching:** Next.js prefetch, Instagram/Facebook route-based prefetch
- **Transitions:** React 18 startTransition, Facebook RN surfaces
- **Screen reuse:** Expo Router nested stacks, React Navigation stateful shells

**References:**
- React Navigation Performance: https://reactnavigation.org/docs/performance
- React 18 Transitions: https://react.dev/reference/react/startTransition
- Expo Router Lazy Loading: https://docs.expo.dev/router/advanced/lazy-loading

---

