# Tasks



---

### Task 35A: Video Upload Cache-Control on PUT ‚úÖ COMPLETED
**Effort:** 0.5 hours | **Priority:** P1 (Performance) | **Depends on:** Task 33

**Summary:** Set object-level Cache-Control during the actual upload (PUT to signed URL) instead of at signed URL creation.

**Rationale:** `createSignedUploadUrl` does not accept `cacheControl`. The correct place is the client PUT request so the object metadata carries `Cache-Control` for CDN.

**Files Modified:**
- `packages/api/src/services/videoUploadService.ts` ‚Üí set headers on both fetch and XHR paths:
  - fetch PUT headers include `Cache-Control: private, max-age=600`
  - XHR PUT uses `xhr.setRequestHeader('Cache-Control', 'private, max-age=600')`

**Acceptance Criteria:**
- ‚úÖ Objects uploaded to `raw` carry `Cache-Control: private, max-age=600`
- ‚úÖ No type errors (TS) or lint issues
- ‚úÖ Tests pass (API and App)

**Impact:** Enables 10-minute edge reuse for per-user videos without changing privacy (still signed + RLS).

---

### Task 35B: Video Signed URL Session Reuse ‚úÖ COMPLETED
**Effort:** 1 hour | **Priority:** P1 (Performance) | **Depends on:** Task 33

**Summary:** Reuse signed download URLs within the session to improve edge cache hit rate and avoid redundant link generation.

**Files Modified:**
- `packages/app/features/VideoAnalysis/hooks/useHistoricalAnalysis.ts` ‚Üí module-level TTL cache for signed URLs (1h TTL, expire 60s early)
- `packages/api/src/services/storageService.ts` ‚Üí `createSignedDownloadUrl(bucket, path, expiresIn = 3600)` supports TTL
- Tests added in `useHistoricalAnalysis.test.tsx` to assert reuse within session

**Acceptance Criteria:**
- ‚úÖ On first resolve, signed URL generated and cached
- ‚úÖ On rerender/remount in same session, no regeneration; URL reused
- ‚úÖ TTL respected; cache invalidates before expiry window

**Impact:** Fewer storage/auth roundtrips; better edge cache locality.

---

### Task 37A: Text Feedback Cache Strategy Validation ‚úÖ COMPLETED
**Effort:** 0.25 hours | **Priority:** P1 | **Depends on:** None

**Summary:** Validated that text/metadata caching is already optimal for current architecture.

**Findings:**
- Historical data uses `staleTime: Infinity` (immutable) ‚Üí correct
- Active analysis uses Realtime subscriptions (no polling) ‚Üí correct

**Decision:** No changes needed for MVP. Future polish (background revalidation, optimistic updates) remains optional.

---

### Task 35: Video Caching Optimization - Range Requests + HLS Streaming
**Effort:** 5 hours | **Priority:** P1 (Performance) | **Depends on:** Task 33
**User Story:** US-VA-01 (Video Analysis Screen - Instant playback with adaptive streaming)

**STATUS:** üü° **PARTIAL** - Modules 1 (PUT header implementation) and 2 (session reuse) completed; remainder pending

@step-by-step.md - Optimize video delivery with Range requests, Cache-Control headers, and HLS segmented streaming for instant playback and adaptive bitrate.

**OBJECTIVE:** Implement YouTube/Instagram-level video caching with Range request support, proper Cache-Control metadata, and HLS segmented streaming for adaptive bitrate and instant playback.

**RATIONALE:**
- **Current State:** Basic video delivery with signed URLs
  - ‚ùå No Cache-Control headers on video uploads (default caching only)
  - ‚ùå No Range request optimization (full video download required)
  - ‚ùå No segmented streaming (single large file, no bitrate adaptation)
  - ‚ùå Signed URL regenerated per request (breaks edge cache reuse)
  - ‚ùå No prefetch strategy for initial segments
  
- **Future Goal:** Production-grade video delivery
  - ‚úÖ Cache-Control metadata set on upload (`private, max-age=600`)
  - ‚úÖ Range request support for partial content retrieval
  - ‚úÖ HLS segmented streaming (2-6 second chunks, multiple bitrates)
  - ‚úÖ Signed URL reused during session (edge cache benefits within TTL)
  - ‚úÖ Prefetch 1-2 initial segments on screen mount
  - ‚úÖ Security maintained (private URLs, RLS enforcement)

**BENEFITS:**
- ‚ö° **Instant playback:** Initial segments buffered before user taps play
- üì± **Adaptive bitrate:** Player adjusts quality based on network conditions
- üåê **Edge caching:** CDN serves cached segments within TTL window
- üíæ **Bandwidth efficiency:** Only fetch segments user watches
- üéØ **Better UX:** No buffering delays, smooth quality transitions

**CURRENT STATE:**
- ‚úÖ Video preload working (Task 33 - edge warming with Range 0-262143)
- ‚úÖ Signed URL generation functional (`videoUploadService.ts`)
- ‚úÖ Video player supports poster and paused preload
- ‚ùå No Cache-Control headers on video objects
- ‚ùå No HLS transcoding pipeline
- ‚ùå No segment prefetch logic

**SCOPE:**

#### Module 1: Cache-Control Metadata on Upload
**Summary:** Set proper Cache-Control headers during the actual PUT to signed URL (object metadata), not at URL creation.

**File:** `packages/api/src/services/videoUploadService.ts` (modify)

**Tasks:**
- [x] Add `Cache-Control: private, max-age=600` to fetch PUT headers
- [x] Add `Cache-Control: private, max-age=600` via `xhr.setRequestHeader` for XHR path
- [ ] Document cache policy in TRD (private videos, 10-minute edge cache TTL)
- [ ] Verify headers via Supabase Storage dashboard after upload

**Acceptance Criteria:**
- [x] All video uploads include Cache-Control header on the object
- [ ] Edge cache respects 10-minute TTL (manual verification)
- [ ] Private content security maintained

#### Module 2: Signed URL Session Reuse ‚Äî ‚úÖ COMPLETED
**Summary:** Reuse signed URL during user session to benefit from edge caching.

**Files:**
- `packages/app/features/VideoAnalysis/hooks/useHistoricalAnalysis.ts` (module-level signed URL cache with TTL)
- `packages/api/src/services/storageService.ts` (`createSignedDownloadUrl` now accepts TTL)
- `packages/app/features/VideoAnalysis/hooks/useHistoricalAnalysis.test.tsx` (tests for reuse)

**Tasks:**
- [x] Cache signed URL in session cache when first generated
- [x] Reuse cached URL for entire session instead of regenerating
- [x] Add TTL tracking (regenerate if URL expires during long sessions)
- [x] Add logging for URL reuse vs regeneration
- [x] Document pattern in code comments

**Implementation Pattern:**
```typescript
const signedUrlCache = useRef<{ url: string; expiresAt: number } | null>(null)

const getVideoUrl = useCallback(async (storagePath: string) => {
  const now = Date.now()
  if (signedUrlCache.current && signedUrlCache.current.expiresAt > now) {
    return signedUrlCache.current.url // Reuse for edge cache benefit
  }
  
  const { data } = await createSignedDownloadUrl('raw', storagePath, 3600)
  signedUrlCache.current = {
    url: data.signedUrl,
    expiresAt: now + 3500000, // Slightly before actual expiry
  }
  return data.signedUrl
}, [])
```

**Acceptance Criteria:**
- [x] Signed URL reused for session duration
- [x] Edge cache hit rate increases (logs show URL reuse)
- [x] URL regenerated if TTL expires
- [x] No playback failures due to expired URLs

#### Module 3: HLS Segmented Streaming (Future Enhancement)
**Summary:** Document HLS transcoding strategy for future implementation.

**File:** `docs/architecture/video-streaming-strategy.md` (new)

**Tasks:**
- [ ] Research HLS transcoding options (FFmpeg, cloud services)
- [ ] Document segment size strategy (2-6 second chunks)
- [ ] Document bitrate ladder (360p/480p/720p/1080p)
- [ ] Document storage structure for segments and manifests
- [ ] Evaluate Supabase Edge Functions for transcoding vs external service
- [ ] Add cost estimates for transcoding at scale

**Note:** Full HLS implementation out of scope for this task. This module documents the architecture for future work.

**Acceptance Criteria:**
- [ ] Architecture documented with segment structure
- [ ] Transcoding strategy evaluated (FFmpeg vs cloud service)
- [ ] Cost analysis completed
- [ ] Integration points identified (upload pipeline, player)

#### Module 4: Initial Segment Prefetch
**Summary:** Prefetch first 1-2 HLS segments when screen mounts (preparation for HLS).

**File:** `packages/app/features/VideoAnalysis/VideoAnalysisScreen.tsx` (modify)

**Tasks:**
- [ ] Extend existing `warmEdgeCache()` to prefetch multiple ranges
- [ ] Fetch bytes 0-524287 (first 512KB) in addition to existing 256KB
- [ ] Add non-blocking prefetch when videoUri becomes available
- [ ] Add structured logging for prefetch metrics
- [ ] Document prefetch strategy in code comments

**Implementation:**
```typescript
async function prefetchInitialSegments(videoUrl: string): Promise<void> {
  const ranges = ['0-262143', '262144-524287'] // First two 256KB chunks
  
  await Promise.all(
    ranges.map(async (range) => {
      try {
        await fetch(videoUrl, { headers: { Range: `bytes=${range}` } })
      } catch (error) {
        logger.warn('Prefetch failed', { range, error })
      }
    })
  )
}
```

**Acceptance Criteria:**
- [ ] First 512KB prefetched on screen mount
- [ ] Prefetch non-blocking (doesn't delay UI)
- [ ] Edge cache warmed for initial playback
- [ ] Metrics logged (duration, success rate)

#### Module 5: Range Request Support Validation
**Summary:** Verify Supabase Storage supports HTTP Range requests correctly.

**Tasks:**
- [ ] Test Range request against signed URL (curl/fetch)
- [ ] Verify 206 Partial Content response
- [ ] Verify Content-Range header in response
- [ ] Test multiple concurrent Range requests
- [ ] Document Range request behavior in TRD

**Test Commands:**
```bash
# Test Range request
curl -I -H "Range: bytes=0-262143" "<signed_url>"
# Expected: HTTP 206, Content-Range: bytes 0-262143/total_size
```

**Acceptance Criteria:**
- [ ] Supabase Storage returns 206 for Range requests
- [ ] Content-Range header present and correct
- [ ] Concurrent Range requests supported
- [ ] Behavior documented in TRD

#### Module 6: Performance Monitoring
**Summary:** Add metrics to measure caching effectiveness.

**File:** `packages/app/features/VideoAnalysis/VideoAnalysisScreen.tsx` (modify)

**Tasks:**
- [ ] Log URL reuse count per session
- [ ] Log prefetch success/failure rates
- [ ] Log time-to-first-frame after prefetch
- [ ] Add cache hit rate estimates (URL reuse = potential edge hit)
- [ ] Export metrics for analytics dashboard

**Metrics to Capture:**
```typescript
- signedUrlReuseCount: Number of times URL reused (edge cache benefit)
- prefetchDuration: Time to prefetch initial segments
- prefetchSuccess: Boolean (all ranges fetched successfully)
- timeToFirstFrame: Time from play tap to first frame (with prefetch)
- cacheHitEstimate: Estimated edge cache benefit from URL reuse
```

**Acceptance Criteria:**
- [ ] All metrics logged with structured logger
- [ ] Metrics correlate with user experience improvements
- [ ] Data exportable for performance dashboard
- [ ] No PII in metrics

**SUCCESS VALIDATION:**
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] Manual QA: Video playback starts instantly after prefetch
- [ ] Manual QA: Network tab shows Range requests with 206 responses
- [ ] Manual QA: Edge cache logs show URL reuse during session
- [ ] Performance: Time-to-first-frame < 100ms with prefetch

**FILES TO MODIFY:**
- `packages/api/src/services/videoUploadService.ts` (add Cache-Control)
- `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (signed URL caching)
- `packages/app/features/VideoAnalysis/VideoAnalysisScreen.tsx` (prefetch, metrics)
- `docs/spec/TRD.md` (update video delivery section)

**FILES TO CREATE:**
- `docs/architecture/video-streaming-strategy.md` (HLS architecture)

**TECHNICAL NOTES:**
- Supabase Storage supports Range requests natively (HTTP 206)
- Cache-Control can be set per-object via upload metadata
- Signed URLs remain private (no public CDN fanout for user videos)
- HLS transcoding requires separate service (not in Supabase Storage natively)
- Edge cache respects Cache-Control within signed URL TTL window

**FUTURE ENHANCEMENTS (Out of Scope):**
- Full HLS transcoding pipeline with multiple bitrates
- ABR (Adaptive Bitrate) player logic
- Predictive prefetch (next video in history list)
- Offline playback with downloaded segments

---

### Task 36: Audio Feedback Disk Cache - LRU + Prefetch
**Effort:** 3 hours | **Priority:** P1 (Performance) | **Depends on:** Task 33
**User Story:** US-VA-01 (Video Analysis Screen - Instant audio playback)

**STATUS:** üü° **PENDING** - Ready to start after Task 33 validation.

@step-by-step.md - Implement disk+memory LRU cache for audio feedback with prefetch immediately after analysis completes.

**OBJECTIVE:** Eliminate audio playback delays by prefetching and caching audio segments on disk with memory fallback, using content-addressed storage and LRU eviction.

**RATIONALE:**
- **Current State:** Audio fetched on-demand when user plays
  - ‚ùå No prefetch after analysis completes
  - ‚ùå No disk caching (network request every time)
  - ‚ùå Memory cache only (`audioCache.ts` - basic Map)
  - ‚ùå No LRU eviction strategy (unbounded growth)
  - ‚ùå No Cache-Control optimization on audio uploads
  
- **Future Goal:** Instant audio playback with aggressive caching
  - ‚úÖ Prefetch immediately after analysis completes
  - ‚úÖ Disk cache with LRU eviction (expo-file-system)
  - ‚úÖ Memory cache as fast lookup layer
  - ‚úÖ Content-addressed cache keys (`analysisId:timestamp`)
  - ‚úÖ Cache-Control: private, max-age=3600, immutable
  - ‚úÖ Signed URL reuse during session

**BENEFITS:**
- ‚ö° **Instant playback:** Audio ready before user taps play
- üíæ **Offline capable:** Audio available without network
- üåê **Edge cache benefits:** URL reuse allows CDN caching within TTL
- üì± **Reduced bandwidth:** No repeated downloads
- üéØ **Better UX:** No audio loading delays

**CURRENT STATE:**
- ‚úÖ Basic memory cache (`packages/app/features/VideoAnalysis/utils/audioCache.ts`)
- ‚úÖ Audio store (`packages/app/features/VideoAnalysis/stores/feedbackAudio.ts`)
- ‚úÖ Audio playback functional (`AudioPlayer.native.tsx`)
- ‚ùå No disk persistence
- ‚ùå No prefetch logic
- ‚ùå No LRU eviction
- ‚ùå No Cache-Control headers on audio uploads

**SCOPE:**

#### Module 1: Disk Cache Implementation
**Summary:** Add disk persistence layer with LRU eviction using expo-file-system.

**File:** `packages/app/features/VideoAnalysis/utils/audioCache.ts` (extend)

**Tasks:**
- [ ] Add `expo-file-system` dependency for disk storage
- [ ] Implement `DiskAudioCache` class with LRU eviction
- [ ] Store audio files as `{cacheDir}/audio/{analysisId}_{timestamp}.wav`
- [ ] Implement `get(key)`, `set(key, blob)`, `evictOldest()` methods
- [ ] Set max cache size (50MB default, configurable)
- [ ] Track access times for LRU ordering
- [ ] Add cache statistics (hit rate, size, eviction count)
- [ ] Handle disk write failures gracefully

**Implementation:**
```typescript
import * as FileSystem from 'expo-file-system'

interface CacheEntry {
  key: string
  path: string
  size: number
  lastAccessed: number
}

class DiskAudioCache {
  private maxSizeBytes = 50 * 1024 * 1024 // 50MB
  private cacheDir = `${FileSystem.cacheDirectory}audio/`
  private entries: CacheEntry[] = []

  async get(key: string): Promise<string | null> {
    const entry = this.entries.find((e) => e.key === key)
    if (!entry) return null
    
    const exists = await FileSystem.getInfoAsync(entry.path)
    if (!exists.exists) {
      this.removeEntry(key)
      return null
    }
    
    entry.lastAccessed = Date.now()
    return entry.path
  }

  async set(key: string, audioUri: string): Promise<void> {
    const filename = `${key.replace(/:/g, '_')}.wav`
    const path = `${this.cacheDir}${filename}`
    
    // Copy to cache directory
    await FileSystem.copyAsync({ from: audioUri, to: path })
    
    const info = await FileSystem.getInfoAsync(path)
    const size = info.size || 0
    
    this.entries.push({ key, path, size, lastAccessed: Date.now() })
    await this.evictIfNeeded()
  }

  private async evictIfNeeded(): Promise<void> {
    let totalSize = this.entries.reduce((sum, e) => sum + e.size, 0)
    
    while (totalSize > this.maxSizeBytes && this.entries.length > 0) {
      // Sort by lastAccessed (LRU)
      this.entries.sort((a, b) => a.lastAccessed - b.lastAccessed)
      const oldest = this.entries.shift()
      if (oldest) {
        await FileSystem.deleteAsync(oldest.path, { idempotent: true })
        totalSize -= oldest.size
      }
    }
  }
}
```

**Acceptance Criteria:**
- [ ] Audio cached to disk successfully
- [ ] LRU eviction works when cache exceeds 50MB
- [ ] Cache survives app restarts
- [ ] Disk write failures logged but don't crash app
- [ ] Cache statistics tracked (hit rate, size)

#### Module 2: Two-Tier Cache (Memory + Disk)
**Summary:** Extend existing memory cache to check disk before network.

**File:** `packages/app/features/VideoAnalysis/utils/audioCache.ts` (modify)

**Tasks:**
- [ ] Integrate `DiskAudioCache` with existing memory cache
- [ ] Lookup order: Memory ‚Üí Disk ‚Üí Network
- [ ] Promote disk hits to memory cache
- [ ] Write network fetches to both layers
- [ ] Add cache tier logging (MEMORY_HIT, DISK_HIT, NETWORK_FETCH)
- [ ] Handle cache misses gracefully

**Cache Lookup Flow:**
```typescript
async function getCachedAudio(analysisId: number): Promise<string | null> {
  // 1. Check memory cache (fastest)
  const memoryHit = memoryCache.get(analysisId)
  if (memoryHit) {
    logger.debug('audioCache', 'Memory cache hit', { analysisId })
    return memoryHit
  }
  
  // 2. Check disk cache
  const diskHit = await diskCache.get(`${analysisId}:${timestamp}`)
  if (diskHit) {
    logger.debug('audioCache', 'Disk cache hit', { analysisId })
    memoryCache.set(analysisId, diskHit) // Promote to memory
    return diskHit
  }
  
  // 3. Fetch from network
  logger.debug('audioCache', 'Network fetch', { analysisId })
  const audioUri = await fetchAudioFromNetwork(analysisId)
  
  // 4. Populate both caches
  await diskCache.set(`${analysisId}:${timestamp}`, audioUri)
  memoryCache.set(analysisId, audioUri)
  
  return audioUri
}
```

**Acceptance Criteria:**
- [ ] Cache lookup checks memory first, then disk, then network
- [ ] Disk hits promoted to memory
- [ ] Network fetches populate both tiers
- [ ] Cache tier logged for debugging
- [ ] Performance: Memory hit < 1ms, Disk hit < 50ms, Network > 100ms

#### Module 3: Prefetch After Analysis
**Summary:** Prefetch audio immediately when analysis completes.

**Files:**
- `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (modify)
- `packages/app/features/VideoAnalysis/hooks/useFeedbackAudioSource.ts` (modify)

**Tasks:**
- [ ] Add `prefetchAudio(analysisId)` function
- [ ] Call prefetch in `useEffect` when `status === 'completed'`
- [ ] Prefetch all audio segments for analysis (non-blocking)
- [ ] Add structured logging for prefetch metrics
- [ ] Handle prefetch failures gracefully (don't block UI)
- [ ] Track prefetch success rate

**Implementation:**
```typescript
useEffect(() => {
  if (analysisState.status === 'completed' && analysisState.id) {
    void prefetchAudio(analysisState.id).catch((error) => {
      logger.warn('audioCache', 'Prefetch failed', { 
        analysisId: analysisState.id,
        error: error instanceof Error ? error.message : String(error),
      })
    })
  }
}, [analysisState.status, analysisState.id])

async function prefetchAudio(analysisId: number): Promise<void> {
  const startTime = Date.now()
  const audioUrl = await getFirstAudioUrlForFeedback(analysisId)
  
  if (audioUrl) {
    await cacheAudio(analysisId, audioUrl)
    const duration = Date.now() - startTime
    logger.info('audioCache', 'Prefetch completed', { analysisId, duration })
  }
}
```

**Acceptance Criteria:**
- [ ] Prefetch fires immediately when analysis completes
- [ ] Audio cached before user taps play
- [ ] Prefetch non-blocking (doesn't delay UI)
- [ ] Prefetch failures logged but don't crash app
- [ ] Success rate tracked in metrics

#### Module 4: Cache-Control Headers on Audio Upload
**Summary:** Set Cache-Control metadata when uploading audio to `processed` bucket.

**File:** `supabase/functions/ai-analyze-video/workers/audioWorker.ts` (modify)

**Tasks:**
- [ ] Add `cacheControl: 'private, max-age=3600, immutable'` to audio upload
- [ ] Document cache policy (private audio, 1-hour edge cache, immutable)
- [ ] Add structured logging for cache metadata
- [ ] Verify headers via Supabase Storage dashboard
- [ ] Test edge cache behavior with reused signed URLs

**Implementation:**
```typescript
const { error } = await supabase.storage
  .from('processed')
  .upload(audioPath, audioBlob, {
    contentType: 'audio/wav',
    cacheControl: 'private, max-age=3600, immutable', // 1-hour edge cache
    upsert: false, // Content-addressed, no overwrites
  })
```

**Acceptance Criteria:**
- [ ] All audio uploads include Cache-Control header
- [ ] Edge cache respects 1-hour TTL
- [ ] Immutable flag prevents revalidation
- [ ] Private content security maintained

#### Module 5: Signed URL Session Reuse
**Summary:** Reuse signed URL during session to benefit from edge caching.

**File:** `packages/app/features/VideoAnalysis/hooks/useFeedbackAudioSource.ts` (modify)

**Tasks:**
- [ ] Cache signed URL in store when first generated
- [ ] Reuse cached URL for session instead of regenerating
- [ ] Add TTL tracking (regenerate if expires during long sessions)
- [ ] Add logging for URL reuse vs regeneration
- [ ] Document pattern in code comments

**Implementation Pattern:**
```typescript
const urlCache = useRef<{ url: string; expiresAt: number } | null>(null)

const getAudioUrl = useCallback(async (storagePath: string) => {
  const now = Date.now()
  if (urlCache.current && urlCache.current.expiresAt > now) {
    return urlCache.current.url // Reuse for edge cache benefit
  }
  
  const { data } = await createSignedDownloadUrl('processed', storagePath, 3600)
  urlCache.current = {
    url: data.signedUrl,
    expiresAt: now + 3500000, // Slightly before actual expiry
  }
  return data.signedUrl
}, [])
```

**Acceptance Criteria:**
- [ ] Signed URL reused for session duration
- [ ] Edge cache hit rate increases (logs show URL reuse)
- [ ] URL regenerated if TTL expires
- [ ] No playback failures due to expired URLs

#### Module 6: Cache Management UI (Future Enhancement)
**Summary:** Add cache statistics and manual clear option in Settings.

**File:** `apps/expo/app/settings/data-controls.tsx` (modify)

**Tasks:**
- [ ] Display cache size (memory + disk)
- [ ] Display cache hit rate statistics
- [ ] Add "Clear Audio Cache" button
- [ ] Add cache eviction logs
- [ ] Document cache behavior in UI

**Note:** Full UI out of scope for this task. Document pattern for future work.

**Acceptance Criteria:**
- [ ] Cache statistics API available
- [ ] Manual clear function implemented
- [ ] UI integration points documented

**SUCCESS VALIDATION:**
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] `yarn workspace @my/app test audioCache.test.ts` ‚Üí all tests pass
- [ ] Manual QA: Audio plays instantly after analysis completes
- [ ] Manual QA: Audio playback works offline (airplane mode)
- [ ] Manual QA: Cache survives app restart
- [ ] Performance: Audio playback starts < 50ms (disk cache hit)

**FILES TO MODIFY:**
- `packages/app/features/VideoAnalysis/utils/audioCache.ts` (disk cache + LRU)
- `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (prefetch trigger)
- `packages/app/features/VideoAnalysis/hooks/useFeedbackAudioSource.ts` (URL reuse)
- `supabase/functions/ai-analyze-video/workers/audioWorker.ts` (Cache-Control)

**FILES TO CREATE:**
- `packages/app/features/VideoAnalysis/utils/audioCache.test.ts` (disk cache tests)

**TECHNICAL NOTES:**
- expo-file-system provides FileSystem.cacheDirectory for temporary storage
- Cache survives app restarts but may be cleared by OS under storage pressure
- LRU eviction prevents unbounded growth
- Content-addressed keys prevent cache collisions
- Two-tier cache optimizes for speed (memory) and capacity (disk)

**FUTURE ENHANCEMENTS (Out of Scope):**
- Background prefetch for next analysis in history
- Predictive caching based on user behavior
- Cache sync across devices (cloud backup)
- Advanced eviction strategies (frequency-based, not just LRU)

---

### Task 37: Text Feedback Cache Optimization - TanStack Query Tuning
**Effort:** 2 hours | **Priority:** P2 (Performance) | **Depends on:** None
**User Story:** US-VA-01 (Video Analysis Screen - Fast feedback display)

**STATUS:** üü° **PARTIAL** - Modules 1 & 2 not required for MVP (already satisfied by architecture); polish items remain

@step-by-step.md - Optimize TanStack Query configuration for text feedback with proper staleTime, cache busting, and background revalidation.

**OBJECTIVE:** Eliminate unnecessary API calls for text feedback by tuning TanStack Query staleTime, implementing cache busting via updated_at, and enabling background revalidation.

**RATIONALE:**
- **Current State:** TanStack Query with default configuration
  - ‚ùå Default staleTime (0) causes refetch on every mount
  - ‚ùå No cache busting strategy (stale data shown)
  - ‚ùå No background revalidation
  - ‚ùå Feedback refetched even when unchanged
  - ‚ùå No query key optimization
  
- **Future Goal:** Production-grade query caching
  - ‚úÖ staleTime: 5 minutes (feedback rarely changes)
  - ‚úÖ Cache busting via updated_at timestamp in query key
  - ‚úÖ Background revalidation (refetchOnWindowFocus)
  - ‚úÖ Optimistic updates on mutations
  - ‚úÖ Query key includes analysisId + updated_at

**BENEFITS:**
- ‚ö° **Faster navigation:** Cached feedback shown instantly
- üåê **Reduced API calls:** No refetch for unchanged data
- üì± **Better offline:** Cached data available without network
- üéØ **Better UX:** Instant feedback display, background updates

**CURRENT STATE:**
- ‚úÖ TanStack Query integrated (`packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts`)
- ‚úÖ Feedback queries functional
- ‚ùå No staleTime configuration
- ‚ùå No cache busting strategy
- ‚ùå No background revalidation

**SCOPE:**

#### Module 1: Configure staleTime for Feedback Queries
**Summary:** Already satisfied ‚Äî historical uses `staleTime: Infinity` (immutable), active analysis uses Realtime (no polling). No code changes required for MVP.

**File:** `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (modify)

**Tasks:**
- [ ] N/A for MVP (satisfied by existing patterns)
- [ ] Optional polish: background revalidation logs (defer)

**Implementation:**
```typescript
const { data: analysisData } = useQuery({
  queryKey: ['analysis', analysisId, updatedAt],
  queryFn: () => fetchAnalysis(analysisId),
  staleTime: 5 * 60 * 1000, // 5 minutes - feedback rarely changes
  refetchOnWindowFocus: true, // Background revalidation
  refetchOnReconnect: true, // Recover from offline
  enabled: !!analysisId,
})
```

**Acceptance Criteria:**
- [x] Historical data not refetched (Infinity)
- [x] Active analysis updates via Realtime (no polling)
- [ ] Optional polish (deferred)

#### Module 2: Cache Busting via updated_at
**Summary:** Not needed for MVP ‚Äî active analysis already busts via Realtime events; historical data is immutable. Defer.

**Files:**
- `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (modify)
- `packages/api/src/services/analysisService.ts` (modify)

**Tasks:**
- [ ] Deferred (only if we add polling-based flows)

**Implementation:**
```typescript
// Fetch updated_at with analysis data
const { data } = await supabase
  .from('analysis_jobs')
  .select('*, updated_at')
  .eq('id', analysisId)
  .single()

// Use in query key
const queryKey = ['analysis', analysisId, data?.updated_at]

// Realtime subscription includes updated_at
supabase
  .channel('analysis')
  .on('postgres_changes', 
    { event: 'UPDATE', table: 'analysis_jobs', filter: `id=eq.${id}` },
    (payload) => {
      // payload includes updated_at, query key changes, cache invalidated
      queryClient.invalidateQueries(['analysis', id, payload.new.updated_at])
    }
  )
```

**Acceptance Criteria:**
- [x] Realtime updates deliver fresh data for active analysis
- [x] Historical remains stable without cache busting
- [ ] Deferred: updated_at keying for polling scenarios

#### Module 3: Background Revalidation
**Summary:** Enable background refetch to keep data fresh without blocking UI.

**File:** `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (modify)

**Tasks:**
- [ ] Enable `refetchOnWindowFocus: true`
- [ ] Enable `refetchOnReconnect: true`
- [ ] Set `refetchInterval: false` (no polling, use Realtime instead)
- [ ] Add logging for background refetch triggers
- [ ] Document refetch strategy in comments

**Configuration:**
```typescript
const queryConfig = {
  staleTime: 5 * 60 * 1000,
  refetchOnWindowFocus: true, // Refresh when user returns to app
  refetchOnReconnect: true, // Refresh after network recovery
  refetchInterval: false, // No polling - Realtime handles updates
}
```

**Acceptance Criteria:**
- [ ] Background refetch on window focus
- [ ] Background refetch on network reconnect
- [ ] No polling (Realtime subscriptions handle updates)
- [ ] UI not blocked during background refetch

#### Module 4: Optimistic Updates for Mutations
**Summary:** Implement optimistic updates when user modifies feedback.

**File:** `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (modify)

**Tasks:**
- [ ] Add `useMutation` for feedback updates
- [ ] Implement optimistic update in `onMutate`
- [ ] Rollback on error in `onError`
- [ ] Invalidate queries in `onSuccess`
- [ ] Add logging for optimistic update flow
- [ ] Document mutation strategy in comments

**Implementation:**
```typescript
const updateFeedbackMutation = useMutation({
  mutationFn: (params) => updateFeedback(params),
  onMutate: async (newFeedback) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries(['analysis', analysisId])
    
    // Snapshot current data
    const previous = queryClient.getQueryData(['analysis', analysisId, updatedAt])
    
    // Optimistically update cache
    queryClient.setQueryData(['analysis', analysisId, updatedAt], (old) => ({
      ...old,
      feedback: newFeedback,
    }))
    
    return { previous }
  },
  onError: (error, variables, context) => {
    // Rollback on error
    if (context?.previous) {
      queryClient.setQueryData(['analysis', analysisId, updatedAt], context.previous)
    }
  },
  onSuccess: () => {
    // Invalidate to refetch actual data
    queryClient.invalidateQueries(['analysis', analysisId])
  },
})
```

**Acceptance Criteria:**
- [ ] UI updates instantly (optimistic)
- [ ] Rollback on mutation error
- [ ] Refetch on mutation success
- [ ] Error toast shown on rollback

#### Module 5: Query Key Optimization
**Summary:** Optimize query keys for efficient cache management.

**File:** `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (modify)

**Tasks:**
- [ ] Use hierarchical query keys: `['analysis', id, 'feedback']`
- [ ] Separate keys for analysis metadata vs feedback list
- [ ] Enable partial cache invalidation (invalidate feedback, not metadata)
- [ ] Add query key constants to prevent typos
- [ ] Document query key structure in comments

**Query Key Structure:**
```typescript
const QUERY_KEYS = {
  analysis: (id: number, updatedAt?: string) => ['analysis', id, updatedAt],
  analysisFeedback: (id: number) => ['analysis', id, 'feedback'],
  analysisMetadata: (id: number) => ['analysis', id, 'metadata'],
} as const

// Invalidate only feedback, keep metadata cached
queryClient.invalidateQueries(QUERY_KEYS.analysisFeedback(analysisId))
```

**Acceptance Criteria:**
- [ ] Query keys hierarchical and consistent
- [ ] Partial cache invalidation works
- [ ] No query key typos (constants used)
- [ ] Cache management efficient

#### Module 6: Performance Monitoring
**Summary:** Add metrics to measure cache effectiveness.

**File:** `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (modify)

**Tasks:**
- [ ] Log cache hit vs network fetch ratio
- [ ] Log staleTime effectiveness (cache reuse count)
- [ ] Log background refetch triggers
- [ ] Log optimistic update success rate
- [ ] Export metrics for analytics dashboard

**Metrics to Capture:**
```typescript
- cacheHitRate: Ratio of cache hits to network fetches
- staleDataServed: Count of times stale data shown (good - fast UX)
- backgroundRefetchCount: Background refetch trigger count
- optimisticUpdateSuccess: Ratio of successful optimistic updates
- averageQueryTime: Cache hit vs network fetch timing
```

**Acceptance Criteria:**
- [ ] All metrics logged with structured logger
- [ ] Cache hit rate > 80% after initial fetch
- [ ] Metrics correlate with performance improvements
- [ ] Data exportable for performance dashboard

**SUCCESS VALIDATION:**
- [ ] `yarn type-check` passes (0 errors)
- [ ] `yarn lint` passes (0 errors)
- [ ] `yarn workspace @my/app test useAnalysisState.test.ts` ‚Üí all tests pass
- [ ] Manual QA: Feedback shows instantly from cache
- [ ] Manual QA: Background refetch updates data without blocking UI
- [ ] Manual QA: Cache busting works when data changes
- [ ] Performance: Cache hit < 10ms, Network fetch > 100ms

**FILES TO MODIFY:**
- `packages/app/features/VideoAnalysis/hooks/useAnalysisState.ts` (TanStack Query config)
- `packages/api/src/services/analysisService.ts` (include updated_at)

**FILES TO CREATE:**
- None (modifying existing files only)

**TECHNICAL NOTES:**
- TanStack Query v4/v5 supports staleTime natively
- Query keys must be serializable (no functions or symbols)
- Optimistic updates improve perceived performance
- Background revalidation keeps data fresh without blocking UI
- Cache busting via updated_at more reliable than ETags for Supabase

**FUTURE ENHANCEMENTS (Out of Scope):**
- Persistent query cache (save to AsyncStorage across app restarts)
- Predictive prefetch (preload next analysis in history)
- Query deduplication (prevent duplicate requests)
- Advanced cache strategies (time-based vs event-based invalidation)

---
