---
description: Monorepo foundation & architecture
alwaysApply: false
globs: ["**/*"]
---

## Purpose
Establishes a unified foundation for our technology stack, architectural principles, repository structure, and data/security model. Major technical decisions documented in `docs/spec/` (PRD/TRD). Complements `core/development-operations.mdc` for operational workflows.

**Related:** `core/development-operations.mdc`, `quality/testing-unified.mdc`, `quality/error-handling.mdc`, `quality/performance.mdc`, `backend/supabase-backend.mdc`, `backend/supabase-database.mdc`

## Tech Stack & Core Principles

**Frontend:** React Native (Expo) for mobile, Next.js for web  
**UI:** Tamagui (cross-platform component library)  
**Backend:** Supabase (PostgreSQL, Realtime, Storage, Edge Functions)  
**State Management:** Zustand (client-side), TanStack Query (server state/data fetching)  
**Navigation:** Expo Router (file-based routing)  
**Language:** TypeScript exclusively, functional components only  
**Package Management & Tooling:** Yarn 4 workspaces, Turbo for orchestration

### Foundational Requirements
- Mobile-first, cross-platform development within a single codebase
- Enforced path aliases (`@ui/`, `@app/`, `@api/`, `@config/`) managed centrally in `tsconfig.base.json`
- No explicit React imports required (React 17+)
- Prefer named exports for all modules
- Row Level Security (RLS) must be enabled for all database access

## Monorepo Structure
```
project-root/
├── apps/          # Applications
│   ├── expo/      # React Native app (expo-app)
│   └── next/      # Next.js web app (next-app)
├── packages/      # Shared code
│   ├── ui/        # Tamagui components (@my/ui)
│   ├── app/       # Business logic, screens, hooks (@my/app)
│   ├── api/       # Backend integrations & clients (@my/api)
│   └── config/    # Configuration & types (@my/config)
├── docs/          # Documentation
├── supabase/      # Backend configuration
└── .cursorrules   # AI behavior configuration
```

Scaffolding: use `yarn turbo gen` where applicable.

## Data Flow

1. **Client Data Fetching:** Client → TanStack Query → Supabase Client → PostgreSQL
2. **Realtime Updates:** PostgreSQL → Supabase Realtime → Client subscription
3. **File Handling:** Client → Supabase Storage → CDN
4. **Sensitive Operations:** Client → Supabase Edge Functions → Database/Services

## Security Model

- **Row Level Security (RLS):** Enabled by default for all tables
- **Authentication:** JWT-based via Supabase Auth
- **Privileged Logic:** Use Edge Functions for sensitive operations; never expose secrets in client code
- **Secrets Management:** Store secrets in environment variables. Never commit `.env*` files to version control

See `quality/security-best-practices.mdc` and `SECURITY.md` for detailed security practices.

## Performance Guardrails

- Component optimization: `React.memo` for expensive components with stable props
- Large data sets: virtualized lists for efficient rendering
- Code splitting: dynamic imports and tree-shake unused exports
- Asset optimization: optimized image formats, CDN-backed assets
- Caching: edge caching for static content

**Performance Budgets:**
- Web (Next.js): Main route JS bundle ≤ 250KB gzipped; review weekly
- Native (Expo): Avoid large monolithic imports; prefer code splitting
- Images: Use optimized formats and restrict remote image sizes

See `quality/performance.mdc` for more details.

## Architectural Extension Guidelines

- **Feature Screens:** Add new screens to `packages/app`; consume from `apps/*`
- **Shared UI:** Place reusable UI in `packages/ui`; avoid app-specific styles here
- **Backend Access:** Route all backend calls through `packages/api`; do not fetch directly from UI
- **Configuration & Types:** Centralize in `packages/config` for cross-package sharing
- **Path Aliases:** Update `tsconfig.base.json` with new aliases when adding packages

### Adding a New Package
1. Create `packages/<name>` with `package.json` (type: module) and `tsconfig.json`
2. Add to root `workspaces`; set internal dependencies using `"workspace:*"`
3. Define path alias in `tsconfig.base.json` (e.g., `@name/*`)
4. Use named exports only; avoid default exports
5. Add minimal tests and stories (for UI), then run `yarn type-check`
6. Build with Turbo and ensure consumers import via the alias

### Package Naming Conventions
- **Apps:** `expo-app`, `next-app` (match directory names)
- **Shared Packages:** `@my/ui`, `@my/app`, `@my/api`, `@my/config`
- **Internal Dependencies:** Use `workspace:*`
- **Privacy:** All packages must include `"private": true` in `package.json`

## Import Strategy & Package Resolution

### Package-Level Imports (Scoped)
Use `@my/` scoped package names for package-level exports, workspace dependencies in package.json, and cross-package imports:

```typescript
// ✅ Correct - package-level imports
import { Button } from '@my/ui'
import { useAuth } from '@my/app' 
import { supabase } from '@my/api'
```

### Path-Level Imports (Aliases)
Use path aliases for specific file imports within packages and internal package structure navigation:

```typescript
// ✅ Correct - path-level imports  
import { Button } from '@ui/components/Button'
import { useAuth } from '@app/hooks/useAuth'
import { supabase } from '@api/supabase'
```

### Import Resolution Rules
1. Package exports: Always use `@my/` scoped names
2. File imports: Use path aliases (`@ui/`, `@app/`, `@api/`, `@config/`)
3. Never mix: Don't use `@api` without `/*` - use `@api/services/...`
4. Export strategy: Export from package index files for `@my/` imports

## Versioning & Compatibility

- Align Expo SDK versions across `apps` and `packages`
- Pin critical dependencies; use carets only for utilities
- Document breaking changes in `CHANGELOG.md`
- Maintain compatibility matrix for major versions (Expo, RN, Next, Node)

## Version Matrix
| Area          | Current        | Minimum | Source |
| ------------- | -------------- | ------- | ------ |
| Node          | 20.x           | 20.x    | `package.json engines.node` |
| Yarn          | 4.9.3          | 4.0.0   | `package.json packageManager` |
| Expo SDK      | 53.x           | 53.x    | root/workspace `expo` versions |
| React Native  | 0.79.x         | 0.79.x  | root `react-native` |
| React         | 19.x           | 19.x    | root `react` |
| Next.js       | 15.x           | 15.x    | `apps/next/package.json` |
| Turbo         | 1.13.x         | 1.13.x  | root `turbo` |

CI enforces version alignment via Corepack. Any discrepancies must be resolved before PR merge.

## Workspace Scripts Reference
- `yarn native` → `expo-app` (React Native development)
- `yarn web` → `next-app` (Web development)
- `yarn build:web` → `--filter=next-app`
- `yarn build:native` → `--filter=expo-app`
- `yarn test` → `--exclude expo-app` (excludes native from unit tests)
- Supabase:
  - `yarn workspace @my/supabase-functions test` (Vitest for _shared)
  - `yarn workspace @my/supabase-functions test:deno` (Deno for Edge)
  - `yarn test:db` (pgTAP database tests)

## First-Hour Checklist for New Contributors
1. Read this file and `core/development-operations.mdc`
2. Run: `yarn install`, `yarn dev`, `yarn type-check`
3. Confirm path aliases (`@ui/`, `@app/`, `@api/`, `@config/`) in `tsconfig.base.json`
4. Review workspace structure: `apps/` (expo-app, next-app), `packages/` (@my/* packages)
5. Skim `docs/spec/` for PRD/TRD to understand project context