---
description: Standard, copy/paste-safe scaffolds for common patterns in this repo (Expo/Next, Tamagui, Supabase, Zustand, TanStack Query, Expo Router). TypeScript-only.
globs: ["**/*"]
alwaysApply: false
---

# Code Generation Templates

### Usage
- Prefer these templates when scaffolding new modules/screens/components/hooks.
- Keep imports aligned with path aliases (`@ui/`, `@app/`, `@api-client/`, etc.).
- Respect the monorepo structure: apps/* vs packages/*.

## Templates

### Zustand store
```ts
// packages/app/stores/{{name}}.ts
import { create } from 'zustand';

interface {{PascalName}}State {
  isLoading: boolean;
  error: string | null;
  data: unknown | null;
  setLoading: (v: boolean) => void;
  setError: (e: string | null) => void;
  setData: (d: unknown | null) => void;
}

export const use{{PascalName}}Store = create<{{PascalName}}State>((set) => ({
  isLoading: false,
  error: null,
  data: null,
  setLoading: (v) => set({ isLoading: v }),
  setError: (e) => set({ error: e }),
  setData: (d) => set({ data: d }),
}));
```

### TanStack Query hook (query)
```ts
// packages/api-client/src/hooks/use{{name}}.ts
import { useQuery } from '@tanstack/react-query';
import { z } from 'zod';

const {{camel}}Schema = z.object({ /* â€¦ */ });
type {{Pascal}} = z.infer<typeof {{camel}}Schema>;

async function fetch{{Pascal}}(id: string): Promise<{{Pascal}}> {
  const res = await fetch(`/api/{{kebab}}/${id}`);
  if (!res.ok) throw new Error(`Failed to fetch {{kebab}}`);
  const json = await res.json();
  return {{camel}}Schema.parse(json);
}

export const use{{Pascal}} = (id: string) => {
  return useQuery({
    queryKey: ['{{kebab}}', id],
    queryFn: () => fetch{{Pascal}}(id),
    staleTime: 60_000,
  });
};
```

### TanStack Mutation
```ts
// packages/api-client/src/hooks/use{{name}}Mutation.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';

export const use{{Pascal}}Mutation = () => {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: async (payload: unknown) => {
      const res = await fetch(`/api/{{kebab}}`, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) throw new Error('Mutation failed');
      return res.json();
    },
    onSuccess: (_, vars) => {
      qc.invalidateQueries({ queryKey: ['{{kebab}}'] });
    },
  });
};
```

### Cross-platform screen with dependency injection
```tsx
// packages/app/features/{{Feature}}/screen.tsx
import { YStack, H1, Paragraph } from '@ui/index';

export interface {{Feature}}ScreenProps {
  id?: string;
  onNavigate?: () => void;
  linkComponent?: React.ReactNode;
}

export function {{Feature}}Screen({ 
  id, 
  onNavigate, 
  linkComponent 
}: {{Feature}}ScreenProps) {
  return (
    <YStack padding="$4">
      <H1 accessibilityRole="header">{{Feature}} {id}</H1>
      <Paragraph>Content</Paragraph>
      {linkComponent || (
        <Button onPress={onNavigate}>Navigate</Button>
      )}
    </YStack>
  );
}
```

### Expo Router app route
```tsx
// apps/expo/app/{{feature}}/[id].tsx
import { {{Feature}}Screen } from 'app/features/{{feature}}/screen';
import { Stack, useRouter, useLocalSearchParams, Link } from 'expo-router';
import { Button } from '@ui/index';

export default function Screen() {
  const { id } = useLocalSearchParams();
  const router = useRouter();
  
  return (
    <>
      <Stack.Screen options={{ title: '{{Feature}}' }} />
      <{{Feature}}Screen 
        id={id as string}
        onNavigate={() => router.back()}
        linkComponent={
          <Link href="/other" asChild>
            <Button>Go to Other</Button>
          </Link>
        }
      />
    </>
  );
}
```

### Shared UI component (Tamagui)
```tsx
// packages/ui/src/components/{{PascalName}}.tsx
import { styled, Button } from 'tamagui';

export interface {{PascalName}}Props {
  label: string;
  onPress?: () => void;
  accessibilityLabel?: string;
}

export function {{PascalName}}({ label, onPress, accessibilityLabel }: {{PascalName}}Props) {
  return (
    <Button
      onPress={onPress}
      accessibilityRole="button"
      accessibilityLabel={accessibilityLabel ?? label}
    >
      {label}
    </Button>
  );
}
```

### Supabase Edge Function (Deno.serve)
```ts
// supabase/functions/{{kebab}}/index.ts
// deno-lint-ignore-file
import 'jsr:@supabase/functions-js/edge-runtime.d.ts';

Deno.serve(async (req) => {
  try {
    const input = await req.json().catch(() => ({}));
    // TODO: implement
    return new Response(JSON.stringify({ ok: true, input }), {
      headers: { 'content-type': 'application/json' },
      status: 200,
    });
  } catch (e) {
    return new Response(JSON.stringify({ ok: false, error: String(e) }), {
      headers: { 'content-type': 'application/json' },
      status: 500,
    });
  }
});
```

### Typed API client wrapper (fetch + Zod)
```ts
// packages/api-client/src/{{domain}}.ts
import { z } from 'zod';

export interface Http {
  get<T>(url: string): Promise<T>;
  post<T>(url: string, body: unknown): Promise<T>;
}

export function createHttp(base = ''): Http {
  return {
    async get<T>(url) {
      const r = await fetch(base + url);
      if (!r.ok) throw new Error(`GET ${url} ${r.status}`);
      return (await r.json()) as T;
    },
    async post<T>(url, body) {
      const r = await fetch(base + url, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(body),
      });
      if (!r.ok) throw new Error(`POST ${url} ${r.status}`);
      return (await r.json()) as T;
    },
  };
}
```

### Vitest test
```ts
// packages/{{pkg}}/src/{{name}}.test.ts
import { describe, it, expect } from 'vitest';

describe('{{name}}', () => {
  it('works', () => {
    expect(1 + 1).toBe(2);
  });
});
```

### Mobile Screen Template (Cross-Platform)
```tsx
// packages/app/features/{{Feature}}/{{Feature}}Screen.tsx
import { YStack, H1, Text, Button, ScrollView } from '@ui/index';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useMedia } from 'tamagui';

export interface {{Feature}}ScreenProps {
  onNavigateBack?: () => void;
  linkComponent?: React.ReactNode;
}

export function {{Feature}}Screen({ onNavigateBack, linkComponent }: {{Feature}}ScreenProps) {
  const insets = useSafeAreaInsets();
  const media = useMedia();
  
  return (
    <YStack 
      flex={1} 
      backgroundColor="$background"
      paddingTop={insets.top}
    >
      {/* Mobile Header */}
      <XStack 
        padding="$4" 
        alignItems="center" 
        justifyContent="space-between"
        borderBottomWidth={1}
        borderBottomColor="$borderColor"
      >
        <Button 
          variant="ghost" 
          size="$3"
          onPress={onNavigateBack}
          icon={<ChevronLeft />}
        >
          Back
        </Button>
        
        <H1 fontSize="$6" fontWeight="600">
          {{Feature}}
        </H1>
        
        <YStack width="$5" /> {/* Centering spacer */}
      </XStack>
      
      {/* Scrollable Content */}
      <ScrollView 
        flex={1} 
        contentContainerStyle={{ 
          padding: 16,
          paddingBottom: insets.bottom + 16
        }}
      >
        <YStack gap="$4">
          <Text fontSize="$4" color="$gray10">
            {{Feature}} screen content goes here
          </Text>
          
          {linkComponent}
        </YStack>
      </ScrollView>
    </YStack>
  );
}
```

### Mobile Card Component Template
```tsx
// packages/ui/src/components/{{Name}}Card.tsx
import { YStack, XStack, Text, H3, Button, Image, Avatar } from 'tamagui';
import { Pressable } from 'react-native';

export interface {{Name}}CardProps {
  title: string;
  subtitle?: string;
  imageUrl?: string;
  onPress?: () => void;
  onActionPress?: () => void;
  actionLabel?: string;
}

export function {{Name}}Card({
  title,
  subtitle,
  imageUrl,
  onPress,
  onActionPress,
  actionLabel = "View Details"
}: {{Name}}CardProps) {
  return (
    <Pressable onPress={onPress} disabled={!onPress}>
      <YStack
        backgroundColor="$background"
        borderRadius="$4"
        padding="$4"
        gap="$3"
        borderWidth={1}
        borderColor="$borderColor"
        // Mobile-optimized touch feedback
        hoverStyle={{ backgroundColor: "$backgroundHover" }}
        pressStyle={{ scale: 0.98 }}
        minHeight={onPress ? 44 : undefined} // Touch target
      >
        {imageUrl && (
          <Image 
            source={{ uri: imageUrl }}
            width="100%"
            height={160}
            borderRadius="$3"
            resizeMode="cover"
          />
        )}
        
        <YStack gap="$2">
          <H3 fontSize="$5" fontWeight="600" numberOfLines={2}>
            {title}
          </H3>
          
          {subtitle && (
            <Text fontSize="$3" color="$gray10" numberOfLines={3}>
              {subtitle}
            </Text>
          )}
        </YStack>
        
        {onActionPress && (
          <Button
            variant="outlined"
            size="$3"
            onPress={onActionPress}
            minHeight={44} // Touch target
          >
            {actionLabel}
          </Button>
        )}
      </YStack>
    </Pressable>
  );
}
```

### Mobile Form Template  
```tsx
// packages/ui/src/components/{{Name}}Form.tsx
import { YStack, XStack, Input, Button, Text, Label } from 'tamagui';
import { KeyboardAvoidingView, Platform, ScrollView } from 'react-native';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const {{name}}Schema = z.object({
  // Define form fields
  email: z.string().email('Invalid email address'),
  name: z.string().min(2, 'Name must be at least 2 characters'),
});

type {{Name}}FormData = z.infer<typeof {{name}}Schema>;

export interface {{Name}}FormProps {
  onSubmit: (data: {{Name}}FormData) => void;
  isLoading?: boolean;
}

export function {{Name}}Form({ onSubmit, isLoading }: {{Name}}FormProps) {
  const { control, handleSubmit, formState: { errors } } = useForm<{{Name}}FormData>({
    resolver: zodResolver({{name}}Schema),
  });

  return (
    <KeyboardAvoidingView 
      flex={1}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView keyboardShouldPersistTaps="handled">
        <YStack padding="$4" gap="$4">
          {/* Name Field */}
          <YStack gap="$2">
            <Label htmlFor="name" fontSize="$4" fontWeight="500">
              Name
            </Label>
            <Controller
              control={control}
              name="name"
              render={({ field: { onChange, value } }) => (
                <Input
                  id="name"
                  value={value}
                  onChangeText={onChange}
                  placeholder="Enter your name"
                  size="$4"
                  minHeight={44} // Touch target
                  borderColor={errors.name ? '$red8' : '$borderColor'}
                />
              )}
            />
            {errors.name && (
              <Text color="$red10" fontSize="$2">
                {errors.name.message}
              </Text>
            )}
          </YStack>

          {/* Email Field */}
          <YStack gap="$2">
            <Label htmlFor="email" fontSize="$4" fontWeight="500">
              Email
            </Label>
            <Controller
              control={control}
              name="email"
              render={({ field: { onChange, value } }) => (
                <Input
                  id="email"
                  value={value}
                  onChangeText={onChange}
                  placeholder="Enter your email"
                  keyboardType="email-address"
                  autoCapitalize="none"
                  autoComplete="email"
                  size="$4"
                  minHeight={44} // Touch target
                  borderColor={errors.email ? '$red8' : '$borderColor'}
                />
              )}
            />
            {errors.email && (
              <Text color="$red10" fontSize="$2">
                {errors.email.message}
              </Text>
            )}
          </YStack>

          {/* Submit Button */}
          <Button
            size="$5"
            minHeight={44} // Touch target
            marginTop="$4"
            onPress={handleSubmit(onSubmit)}
            disabled={isLoading}
          >
            {isLoading ? 'Submitting...' : 'Submit'}
          </Button>
        </YStack>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}
```

### Mobile List Item Template
```tsx
// packages/ui/src/components/{{Name}}ListItem.tsx
import { YStack, XStack, Text, H4, Button, Avatar } from 'tamagui';
import { Pressable } from 'react-native';

export interface {{Name}}ListItemProps {
  title: string;
  subtitle?: string;
  avatarUrl?: string;
  onPress?: () => void;
  onActionPress?: () => void;
  actionIcon?: React.ReactNode;
  isLast?: boolean;
}

export function {{Name}}ListItem({
  title,
  subtitle,
  avatarUrl,
  onPress,
  onActionPress,
  actionIcon,
  isLast = false
}: {{Name}}ListItemProps) {
  return (
    <Pressable onPress={onPress} disabled={!onPress}>
      <XStack
        alignItems="center"
        padding="$4"
        minHeight={60} // Touch target + content
        borderBottomWidth={isLast ? 0 : 1}
        borderBottomColor="$borderColor"
        hoverStyle={{ backgroundColor: "$backgroundHover" }}
        pressStyle={{ backgroundColor: "$backgroundPress" }}
        gap="$3"
      >
        {/* Avatar/Icon */}
        {avatarUrl && (
          <Avatar size="$5">
            <Avatar.Image source={{ uri: avatarUrl }} />
            <Avatar.Fallback backgroundColor="$blue5">
              <Text fontSize="$4">{title.charAt(0)}</Text>
            </Avatar.Fallback>
          </Avatar>
        )}
        
        {/* Content */}
        <YStack flex={1} gap="$1">
          <H4 fontSize="$4" fontWeight="500" numberOfLines={1}>
            {title}
          </H4>
          {subtitle && (
            <Text fontSize="$3" color="$gray10" numberOfLines={2}>
              {subtitle}
            </Text>
          )}
        </YStack>
        
        {/* Action */}
        {onActionPress && (
          <Button
            variant="ghost"
            size="$3"
            onPress={onActionPress}
            icon={actionIcon}
            circular
            minWidth={44}
            minHeight={44} // Touch target
          />
        )}
      </XStack>
    </Pressable>
  );
}
```

