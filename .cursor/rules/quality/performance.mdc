---
description: Performance optimization for fast MVP iteration
globs: ["**/components/**/*", "**/*.tsx", "**/hooks/**/*", "**/screens/**/*"]
alwaysApply: false
---

# Performance Rules

## React Optimization
- Use React.memo for expensive components ONLY
- Prefer useMemo for expensive computations
- AVOID premature optimization in MVP phase

```typescript
// ✅ Good - only for expensive renders
const ExpensiveList = memo(({ items }: { items: Item[] }) => (
  <YStack>{items.map(item => <ExpensiveItem key={item.id} item={item} />)}</YStack>
))

// ❌ Bad - unnecessary memo
const SimpleButton = memo(({ title }: { title: string }) => <Button>{title}</Button>)
```

## TanStack Query Optimization
- Use staleTime for stable data
- Enable background refetch for user data
- Implement optimistic updates for mutations

```typescript
// ✅ Good - cache stable data
const { data } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId),
  staleTime: 5 * 60 * 1000 // 5 minutes
})

// ✅ Good - optimistic updates
const updateMutation = useMutation({
  mutationFn: updatePost,
  onMutate: async (newPost) => {
    queryClient.setQueryData(['posts', id], newPost)
  }
})
```

## Images and Assets
- Use optimized Image components with proper sizing
- Lazy load images below fold
- Use optimized formats (WebP/AVIF for web)

```typescript
// ✅ Good - Next.js
import Image from 'next/image'
<Image 
  src="/image.jpg" 
  width={300} 
  height={200}
  priority={isAboveFold}
/>

// ✅ Good - React Native
import { Image } from 'react-native'
<Image 
  source={{ uri: '/image.jpg' }} 
  style={{ width: 300, height: 200 }}
/>

// ❌ Bad - no dimensions
<Image src="/image.jpg" />
```

## List Performance
- Use FlatList for long lists on native
- Implement proper keyExtractor
- Use getItemLayout when possible

```typescript
// ✅ Good
<FlatList
  data={items}
  keyExtractor={(item) => item.id}
  getItemLayout={(data, index) => ({ length: 80, offset: 80 * index, index })}
  renderItem={({ item }) => <Item item={item} />}
/>
```

## Bundle Size (MVP Focus)
- Use dynamic imports for non-critical features
- Tree-shake unused Tamagui components
- AVOID heavy libraries during MVP phase

```typescript
// ✅ Good - lazy load admin features
const AdminPanel = lazy(() => import('../admin/AdminPanel'))

// ✅ Good - specific Tamagui imports
import { Button, XStack } from '@tamagui/core'
```