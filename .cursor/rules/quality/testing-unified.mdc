---
description: Unified testing strategy for monorepo
globs: ["**/*.test.*", "**/*.spec.*", "e2e/**/*"]
alwaysApply: false
---

# Testing Strategy

## CRITICAL: Use Correct Test Runner
- **React Native/Expo: Jest with jest-expo preset**
- **Web/Node.js: Vitest**
- **NEVER use Vitest for React Native testing**

## Environment-Specific Testing

### React Native/Expo (Jest)
- Use `jest-expo` preset
- Test with `@testing-library/react-native`
- Mock React Native modules properly
- Use `jsdom` environment for component tests
- Test user interactions, not implementation details

### Web/Node.js (Vitest)
- Use `jsdom` environment for React components
- Use `node` environment for utilities
- Mock browser APIs when needed
- Test business logic and utilities

## Unit/Integration Tests

### Jest (React Native)
```typescript
// apps/expo/__tests__/component.test.tsx
import React from "react";

describe("MyComponent", () => {
  it("passes basic tests", () => {
    expect(1 + 1).toBe(2);
  });

  it("can import React", () => {
    expect(React).toBeDefined();
  });
});
```

### Vitest (Web/Node)
```typescript
// apps/next/__tests__/utils.test.ts
import { describe, it, expect } from 'vitest'
import { formatDate } from '../utils/date'

describe('formatDate', () => {
  it('formats date correctly', () => {
    expect(formatDate(new Date('2024-01-01'))).toBe('Jan 1, 2024')
  })
})
```

## Component Tests
- Colocate tests with source files
- Use `.test.tsx` or `.spec.tsx` extensions
- Test user interactions, not implementation
- Mock external dependencies (Supabase, etc.)
- Test accessibility where applicable

## E2E Tests
### Detox (React Native)
- Use `testID` props consistently
- `waitFor` elements before interactions
- Independent test suites
- Test on actual device/simulator

### Playwright (Web)
- Test critical user flows
- Use page object pattern
- Run against preview deployments

## Setup Requirements

### Jest Setup (React Native)
```typescript
// apps/expo/__tests__/setup.ts
// Mock Expo modules for testing
jest.mock('expo-router', () => ({
  useRouter: () => ({ push: jest.fn(), replace: jest.fn() }),
  useLocalSearchParams: () => ({}),
  Link: 'Link',
}))

jest.mock('expo-constants', () => ({
  expoConfig: { extra: {} },
}))
```

**Note:** When using `jest-expo` preset, React Native module mocking is handled automatically. Only mock Expo-specific modules as needed.

### Jest Manual Mocks (Preferred for Complex Modules)
For internal workspace packages or complex modules, use manual mocks in `__mocks__` directory:

```javascript
// packages/ui/__mocks__/@my/config.js
const shadows = {
  small: { shadowColor: 'rgba(0,0,0,0.1)', elevation: 1 },
  medium: { shadowColor: 'rgba(0,0,0,0.15)', elevation: 2 },
  // ... other shadow levels
}

module.exports = {
  shadows,
  config: { tokens: {}, themes: {} },
  __esModule: true,
  default: { shadows, config: { tokens: {}, themes: {} } }
}
```

**Why Manual Mocks?**
- More reliable than inline `jest.mock()` calls
- Better for TypeScript-only packages that can't be imported by Node.js
- Handles complex module resolution issues
- Avoids circular dependency problems

### Vitest Setup (Web)
```typescript
// apps/next/__tests__/setup.ts
import '@testing-library/jest-dom'
import { vi } from 'vitest'

// Mock browser APIs
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: vi.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: vi.fn(),
    removeListener: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn(),
  })),
})
```

## Supabase Testing
- Use Supabase local development
- Test migrations with `supabase db reset`
- Test Edge Functions locally
- Mock auth for protected routes

## Coverage Requirements
- Unit: 80% for business logic
- Integration: Key user flows
- E2E: Critical paths only

## What NOT to Test (Anti-Patterns)(NEVER DO)
- ❌ Using Vitest for React Native testing
- ❌ Testing React Native modules with Node.js require()
- ❌ Ignoring established testing patterns
- ❌ Mock implementations of internal hooks
- ❌ Every possible state combination
- ❌ Implementation details (function calls, internal state)
- ❌ Edge cases that users never encounter
- ❌ Platform-specific behavior unless critical

## Test Review Questions
1. "Would a user notice if this test failed?"
2. "Is this testing behavior or implementation?"
3. "Could this test be 50% shorter?"
4. "Are we mocking too much?"

## Validation Checklist
Before declaring something "broken":
□ Test in the correct runtime environment
□ Use Jest for React Native, Vitest for web/Node
□ Verify the app actually works (not just imports)
□ Check if user can reproduce the issue
□ Follow established testing patterns
□ Test user interactions, not implementation details
□ Try manual mocks for complex module resolution issues
□ For test debugging, follow @debugging.mdc → "Test Debugging" section

## Test Efficiency Guidelines

### CRITICAL: Maintain Test-to-Code Ratio
- **Target Ratio**: 1:2 (1 line of test per 2 lines of code)
- **Maximum Ratio**: 1:1 (never exceed code length)
- **Red Flag**: If test > code, you're testing wrong things

### Test Scope Rules
- **Unit Tests**: Test single function/component behavior
- **Integration Tests**: Test 2-3 components working together
- **E2E Tests**: Test complete user flows only


### What TO Test (User-Focused)
- ✅ User-visible behavior and interactions
- ✅ Critical user flows (happy path + 1-2 error cases)
- ✅ Integration points where components connect
- ✅ Accessibility and usability

### Test Writing Checklist
Before writing a test, ask:
1. Does this test user-visible behavior?
2. Would a user notice if this broke?
3. Is this the simplest test that proves it works?
4. Am I testing implementation or behavior?

### Test Bloat Prevention
- **One test per user action** (not per internal function call)
- **Mock only external dependencies** (APIs, file system, network)
- **Use real components** when possible (not mocked versions)
- **Focus on integration points** where bugs actually occur