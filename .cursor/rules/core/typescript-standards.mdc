---
description: TypeScript configuration and standards for cross-platform development
globs: ["**/*.ts", "**/*.tsx", "tsconfig.json", "**/*.d.ts"]
alwaysApply: false
---

# TypeScript Standards

## Core Principles
- Always enable strict mode in `tsconfig.json`.
- Avoid using `any` or `unknown` types unless absolutely necessary and justified with a comment.
- All exported functions must have explicit return types.
- Use `type` for unions and intersections; use `interface` for object shapes.
- Prefer `as const` assertions over enums, e.g., `const Status = ['pending', 'completed'] as const`.

## Cross-Platform Type Practices
- Leverage conditional types to handle platform-specific APIs.
- Place shared interfaces in `packages/app/types`.
- Define platform-specific types in files named `*.native.ts` or `*.web.ts`.
- For Tamagui components, use `GetProps<typeof Component>` to extract prop types.

## Supabase Type Integration
- Generate database types with:  
  `yarn supabase gen types typescript --local > packages/api/types/database.ts`
- Use the generated `Database` type for all Supabase queries.
- Type the Supabase client as `SupabaseClient<Database>`.
- For table rows, use:  
  `Database['public']['Tables']['table_name']['Row']`

## Zod Integration Guidelines
- Validate all external data at runtime using Zod schemas.
- For API responses, define schemas, e.g., `const UserSchema = z.object({...})`.
- Use Zod with react-hook-form for form input validation.
- Define navigation parameter schemas, e.g., `const ParamsSchema = z.object({...})`.
- Keep Zod schemas in sync with SQL/database schemas.

## Tamagui Typing
- Use `styled()` to create custom components with type safety.
- Extract prop types with the `GetProps<>` utility.
- Extend `TamaguiConfig` to type custom theme tokens.
- Use `ResponsiveValue<T>` for responsive prop typing.

## Error Handling Patterns
- Create custom error classes that extend the built-in `Error`.
- Use discriminated unions for result types, for example:
  ```typescript
  type Result<T, E = Error> =
    | { success: true; data: T }
    | { success: false; error: E }
  ```

## Import Conventions

### Monorepo Import Patterns
- **Package imports**: Use `import { Component } from '@my/ui'` for main package exports.
- **Path imports**: Use `import { Component } from '@ui/components/Button'` for specific files.
- **Do not** import from `@api` without a path; always use the full path, e.g., `@api/services/...`.

### TypeScript Path Resolution
- Define all path aliases in `tsconfig.base.json`.
- Use scoped package names in `package.json` dependencies.
- Re-export functions and types from package index files to support `@my/` imports.