---
description: TypeScript configuration and standards for cross-platform development
globs: ["**/*.ts", "**/*.tsx", "tsconfig.json", "**/*.d.ts"]
alwaysApply: false
---

# TypeScript Standards

**Package context:** See `packages/app/AGENTS.md` and `packages/api/AGENTS.md` for package-specific type conventions.

## Core Principles
- Always enable strict mode in `tsconfig.json`.
- Avoid using `any` or `unknown` types unless absolutely necessary and justified with a comment.
- All exported functions must have explicit return types.
- Use `type` for unions and intersections; use `interface` for object shapes.
- Prefer `as const` assertions over enums, e.g., `const Status = ['pending', 'completed'] as const`.

### Avoid papering over type inference
- Don’t use `as any` to “fix” inference issues in callbacks. If inference breaks, fix the expression shape first (common culprit: extra parentheses like `((...))`).

```typescript
// ❌ Bad: extra parentheses confuse inference; `as any` just hides the bug
const unsubscribe = someFunction(arg, ((p1, p2) => {
  handleUpdate(p1, p2)
}) as any)
```

```typescript
// ✅ Better: remove the extra parentheses and let TS infer naturally
const unsubscribe = someFunction(arg, (p1, p2) => {
  handleUpdate(p1, p2)
})
```

## Cross-Platform Type Practices
- Leverage conditional types to handle platform-specific APIs.
- Place shared interfaces in `packages/app/types`.
- Define platform-specific types in files named `*.native.ts` or `*.web.ts`.
- For Tamagui components, use `GetProps<typeof Component>` to extract prop types.

## Supabase Type Integration
- Use the generated `Database` type for all Supabase queries.

## Zod Integration Guidelines
- Validate all external data at runtime using Zod schemas.
- Keep Zod schemas in sync with SQL/database schemas.

## Tamagui Typing
- Use `styled()` to create custom components with type safety.
- Extract prop types with the `GetProps<>` utility.
- Extend `TamaguiConfig` to type custom theme tokens.
- Use `ResponsiveValue<T>` for responsive prop typing.

## Error Handling Patterns
- Create custom error classes that extend the built-in `Error`.
- Use discriminated unions for result types, for example:
  ```typescript
  type Result<T, E = Error> =
    | { success: true; data: T }
    | { success: false; error: E }
  ```

## Import Conventions

### Monorepo Import Patterns
- **Package imports**: Use `import { Component } from '@my/ui'` for main package exports.
- **Path imports**: Use `import { Component } from '@ui/components/Button'` for specific files.
- **Do not** import from `@api` without a path; always use the full path, e.g., `@api/services/...`.

### TypeScript Path Resolution
- Define all path aliases in `tsconfig.base.json`.
- Use scoped package names in `package.json` dependencies.
- Re-export functions and types from package index files to support `@my/` imports.