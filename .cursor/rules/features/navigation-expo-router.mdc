---
description: Expo Router navigation for cross-platform routing
alwaysApply: false
---
# Navigation Rules - Battle-Tested Pattern

**Package context:** See `packages/app/AGENTS.md` for screen organization.

## Core Principles

### 1. Separation of Concerns
- **Screens** (`packages/app/features/`): Business logic only, NO navigation imports
- **Route Files** (`apps/{expo,web}/app/`): All navigation logic, header config, routing

### 2. Single API Source (Expo Router Native)
- ✅ Use Expo Router APIs: `useRouter()`, `useLocalSearchParams()`, `Link`
- ✅ Use `useHeaderHeight()` from `@react-navigation/elements` (utility hook only)
- ❌ NEVER use `useNavigation()` from Expo Router in screens
- ❌ NEVER use React Navigation directly

### 3. Dependency Injection
- Route files pass navigation callbacks as props
- Screens accept callbacks: `onBack?: () => void`, `onNavigate?: (route: string) => void`
- Headers configured in route file via `Stack.Screen options` or `useNavigation().setOptions()`

## Implementation Patterns

### Static Headers (Preferred)
```typescript
// ✅ Route file - static header configuration
// apps/expo/app/(tabs)/insights.tsx
import { Tabs } from 'expo-router'

export default function InsightsTab() {
  const router = useRouter()
  
  return (
    <>
      <Tabs.Screen
        name="insights"
        options={{
          title: "Insights",
          headerRight: () => <Button onPress={() => router.push('/settings')}>Settings</Button>
        }}
      />
      <InsightsScreen />
    </>
  )
}

// ✅ Screen - no navigation imports
// packages/app/features/Insights/InsightsScreen.tsx
export function InsightsScreen({ testID }: InsightsScreenProps) {
  // Just business logic and UI
  return <YStack>{/* ... */}</YStack>
}
```

### Dynamic Headers (When Needed)
```typescript
// ✅ Route file - dynamic header via callback props
// apps/expo/app/(tabs)/record.tsx
import { useNavigation } from 'expo-router' // Only in route files!

export default function RecordTab() {
  const router = useRouter()
  const navigation = useNavigation()
  
  const handleHeaderStateChange = useCallback((state: HeaderState) => {
    navigation.setOptions({
      headerTitle: () => <RecordingTimer time={state.time} />,
      headerRight: () => <RecordingModeIndicator mode={state.mode} />
    })
  }, [navigation])
  
  return (
    <AuthGate>
      <CameraRecordingScreen
        onHeaderStateChange={handleHeaderStateChange}
        onVideoProcessed={(uri) => router.push('/video-analysis')}
      />
    </AuthGate>
  )
}

// ✅ Screen - communicates header state via callback
// packages/app/features/CameraRecording/CameraRecordingScreen.tsx
export function CameraRecordingScreen({
  onHeaderStateChange,
  onVideoProcessed
}: CameraRecordingScreenProps) {
  useEffect(() => {
    onHeaderStateChange?.({ time: duration, mode: recordingState })
  }, [duration, recordingState, onHeaderStateChange])
  
  // Business logic only
}
```

### Navigation Callbacks
```typescript
// ✅ Screen accepts callbacks as props
export interface ScreenProps {
  onBack?: () => void
  onNavigate?: (route: string) => void
  onVideoProcessed?: (uri: string) => void
}

// ✅ Route file implements callbacks
<Screen
  onBack={() => router.back()}
  onNavigate={(route) => router.push(route)}
  onVideoProcessed={(uri) => router.push({ pathname: '/analysis', params: { uri }})}
/>
```

## File-Based Routing

- Routes live in `apps/{expo,web}/app/` directory
- Use typed navigation params with `useLocalSearchParams<T>()`
- Dynamic routes: `[id].tsx` for `/route/:id`
- Groups: `(tabs)/` for tab navigation

## Testing Strategy

### Screen Tests
```typescript
// ✅ Test business logic with mocked callbacks
it('should call onVideoProcessed when recording completes', () => {
  const mockOnVideoProcessed = jest.fn()
  render(<CameraRecordingScreen onVideoProcessed={mockOnVideoProcessed} />)
  
  // Trigger recording completion
  fireEvent.press(screen.getByTestId('stop-button'))
  
  expect(mockOnVideoProcessed).toHaveBeenCalledWith('video-uri')
})
```

### Route Tests
```typescript
// ✅ Test navigation logic in route files
it('should navigate to video analysis after processing', () => {
  const { router } = renderRouter('/record')
  
  // Simulate video processing
  act(() => {
    router.push({ pathname: '/video-analysis', params: { videoUri: 'test-uri' }})
  })
  
  expect(router).toHavePathname('/video-analysis')
})
```

## Benefits of This Pattern

1. **Testability**: Mock callbacks, not hooks
2. **Reusability**: Screens work in any navigation context
3. **Framework-Agnostic**: Screens can be used outside Expo Router
4. **Type Safety**: Explicit interfaces for all navigation behaviors
5. **Future-Proof**: Aligns with Expo Router roadmap

## Migration Checklist

When refactoring screens to this pattern:
- [ ] Remove all `useNavigation()` imports from screen files
- [ ] Remove all `useRouter()` imports from screen files (except `useHeaderHeight()`)
- [ ] Add callback props to screen interface
- [ ] Move navigation logic to route files
- [ ] Update header configuration in route files
- [ ] Update tests to mock callbacks instead of navigation hooks

## Cross-Links
- Screen organization: `packages/app/AGENTS.md`
- Route protection: `.cursor/rules/features/authentication.mdc`
- TypeScript standards: `.cursor/rules/core/typescript-standards.mdc`