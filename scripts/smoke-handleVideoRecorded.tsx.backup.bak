// Set environment variables before any imports - MUST be at the very top
process.env.EXPO_PUBLIC_SUPABASE_URL = 'http://127.0.0.1:54321'
process.env.EXPO_PUBLIC_SUPABASE_KEY = 'sb_publishable_ACJWlzQHlZjBrEguHvfOxg_3BJgxAaH'
process.env.TEST_USER_EMAIL = 'testuser@example.com'
process.env.TEST_USER_PASSWORD = 'testpass123'

/**
 * Smoke Test: Pipeline Integration via useCameraScreenLogic
 * Tests the complete pipeline from handleVideoRecorded to analysis completion
 */

// Disable @my/api mocks to enable real Supabase calls
jest.unmock('@my/api')

import { readFileSync } from 'node:fs'
import { join } from 'node:path'
import { useUploadProgressStore } from '../packages/app/stores'
import { supabase } from '@my/api'
import { getAnalysisJobByVideoId } from '@my/api'
import { act, render } from '@testing-library/react'
import { enableMapSet } from 'immer'
import React from 'react'

// Create mock data outside of jest.mock
const mockVideoBuffer = readFileSync(
  join(process.cwd(), '../../test-assets', 'videos', 'mini_speech.mp4')
)

// Mock uriToBlob to return real Blob from test asset
jest.mock('../../../utils/files', () => ({
  uriToBlob: async () => {
    // Return the mock video buffer regardless of the path
    return new Blob([mockVideoBuffer], { type: 'video/mp4' })
  },
}))

// Force web compression implementation
jest.mock('../../../services/videoCompression', () => {
  const webCompression = require('../../../services/videoCompression.web')
  return webCompression
})

// Test component that uses the hook
function TestCameraScreenLogic({
  onNavigateToVideoAnalysis,
  onHandleVideoRecordedReady,
}: {
  onNavigateToVideoAnalysis: (videoUri: string) => void
  onHandleVideoRecordedReady: (handleVideoRecorded: (videoUri: string) => Promise<void>) => void
}) {
  const cameraRef = { current: null } // Mock camera ref
  const { handleVideoRecorded } = require('../hooks/useCameraScreenLogic').useCameraScreenLogic({
    onNavigateBack: () => {},
    onNavigateToVideoAnalysis,
    onTabChange: () => {},
    cameraRef,
  })

  // Expose handleVideoRecorded to parent
  React.useEffect(() => {
    onHandleVideoRecordedReady(handleVideoRecorded)
  }, [handleVideoRecorded, onHandleVideoRecordedReady])

  return <div data-testid="test-component">Camera Screen Logic Test</div>
}

describe('handleVideoRecorded Pipeline Smoke Test', () => {
  const testVideoPath = join(process.cwd(), 'test-assets', 'videos', 'mini_speech.mp4')
  const testVideoUri = `file://${testVideoPath}`

  // Load environment variables and setup
  beforeAll(() => {
    // Enable Immer MapSet plugin for Zustand stores
    enableMapSet()
  })

  beforeEach(() => {
    // Reset upload progress store
    useUploadProgressStore.getState().clearAll()
  })

  it('should complete full pipeline from recording to analysis', async () => {
    // Skip if required environment variables are missing
    const requiredEnv = [
      'EXPO_PUBLIC_SUPABASE_URL',
      'EXPO_PUBLIC_SUPABASE_KEY',
      'TEST_USER_EMAIL',
      'TEST_USER_PASSWORD',
    ]

    const missingEnv = requiredEnv.filter((env) => !process.env[env])
    if (missingEnv.length > 0) {
      throw new Error(`Missing environment variables: ${missingEnv.join(', ')}`)
    }

    const email = process.env.TEST_USER_EMAIL!
    const password = process.env.TEST_USER_PASSWORD!

    const { error: signInError } = await supabase.auth.signInWithPassword({ email, password })
    if (signInError) {
      throw new Error(`Failed to authenticate test user ${email}: ${signInError.message}`)
    }

    const {
      data: { user },
      error: userError,
    } = await supabase.auth.getUser()

    if (userError || !user) {
      throw new Error(`Authenticated user not available: ${userError?.message ?? 'unknown error'}`)
    }

    // Track navigation calls and handleVideoRecorded function
    let navigatedVideoUri: string | null = null
    let handleVideoRecorded: ((videoUri: string) => Promise<void>) | null = null

    const onNavigateToVideoAnalysis = (videoUri: string) => {
      navigatedVideoUri = videoUri
    }

    const onHandleVideoRecordedReady = (fn: (videoUri: string) => Promise<void>) => {
      handleVideoRecorded = fn
    }

    // Mount React component using the hook
    await act(async () => {
      render(
        <TestCameraScreenLogic
          onNavigateToVideoAnalysis={onNavigateToVideoAnalysis}
          onHandleVideoRecordedReady={onHandleVideoRecordedReady}
        />
      )
    })

    // Wait for handleVideoRecorded to be available
    while (!handleVideoRecorded) {
      await new Promise((resolve) => setTimeout(resolve, 10))
    }

    // Trigger video recording completion
    await act(async () => {
      await handleVideoRecorded!(testVideoUri)
    })

    // Verify immediate navigation
    expect(navigatedVideoUri).toBe(testVideoUri)

    // Wait for upload to complete and get videoRecordingId
    let videoRecordingId: number | null = null
    const maxWaitTime = 60000 // 60 seconds for upload
    const pollInterval = 1000 // 1 second

    for (let i = 0; i < maxWaitTime / pollInterval; i++) {
      await new Promise((resolve) => setTimeout(resolve, pollInterval))

      const tasks = useUploadProgressStore.getState().getUploadsByStatus('completed')
      const uploadTask = tasks.find((task) => task.filename === 'recorded_video.mp4')

      if (uploadTask?.videoRecordingId && uploadTask.status === 'completed') {
        videoRecordingId = uploadTask.videoRecordingId
        break
      }
    }

    expect(videoRecordingId).toBeTruthy()

    const { data: videoRecording, error: videoRecordingError } = await supabase
      .from('video_recordings')
      .select('*')
      .eq('id', videoRecordingId!)
      .single()

    if (videoRecordingError || !videoRecording) {
      throw new Error(
        `Uploaded video_recordings row missing: ${videoRecordingError?.message ?? 'not found'}`
      )
    }

    // Poll analysis job until completion
    const analysisMaxWaitTime = 300000 // 5 minutes for analysis
    const analysisPollInterval = 5000 // 5 seconds

    for (let i = 0; i < analysisMaxWaitTime / analysisPollInterval; i++) {
      await new Promise((resolve) => setTimeout(resolve, analysisPollInterval))

      const job = await getAnalysisJobByVideoId(videoRecordingId!)

      if (job) {
        if (job.status === 'completed') {
          // Success! Analysis completed
          expect(job.status).toBe('completed')
          expect(job.results).toBeTruthy()
          break
        }
        if (job.status === 'failed') {
          throw new Error(`Analysis failed: ${job.error_message}`)
        }
        // Continue polling if still processing or queued
      }
    }

    // If we reach here without breaking, analysis timed out
    const finalJob = await getAnalysisJobByVideoId(videoRecordingId!)
    if (finalJob?.status !== 'completed') {
      throw new Error('Analysis timed out or failed to start')
    }
  }, 600000) // 10 minute timeout for full pipeline
})
